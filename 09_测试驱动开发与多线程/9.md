# æµ‹è¯•é©±åŠ¨å¼€å‘ä¸å¤šçº¿ç¨‹

- [æµ‹è¯•é©±åŠ¨å¼€å‘ä¸å¤šçº¿ç¨‹](#æµ‹è¯•é©±åŠ¨å¼€å‘ä¸å¤šçº¿ç¨‹)
  - [æµ‹è¯•é©±åŠ¨å¼€å‘å¤šçº¿ç¨‹åº”ç”¨çš„æ ¸å¿ƒæ¦‚å¿µ](#æµ‹è¯•é©±åŠ¨å¼€å‘å¤šçº¿ç¨‹åº”ç”¨çš„æ ¸å¿ƒæ¦‚å¿µ)
  - [ç¤ºä¾‹ç¨‹åº GeoServer](#ç¤ºä¾‹ç¨‹åº-geoserver)
  - [æ€§èƒ½è¦æ±‚](#æ€§èƒ½è¦æ±‚)
  - [è®¾è®¡å¼‚æ­¥æ–¹æ¡ˆ](#è®¾è®¡å¼‚æ­¥æ–¹æ¡ˆ)
  - [ä¾ç„¶ç®€å•çš„æµ‹è¯•é©±åŠ¨](#ä¾ç„¶ç®€å•çš„æµ‹è¯•é©±åŠ¨)
  - [ä¸ºå¤šçº¿ç¨‹åšå¥½å‡†å¤‡](#ä¸ºå¤šçº¿ç¨‹åšå¥½å‡†å¤‡)
  - [æš´éœ²å¹¶å‘æ€§é—®é¢˜](#æš´éœ²å¹¶å‘æ€§é—®é¢˜)
  - [åœ¨æµ‹è¯•ä¸­åˆ›å»ºå®¢æˆ·ç«¯çº¿ç¨‹](#åœ¨æµ‹è¯•ä¸­åˆ›å»ºå®¢æˆ·ç«¯çº¿ç¨‹)
  - [åœ¨ ThreadPool ä¸­åˆ›å»ºå¤šä¸ªçº¿ç¨‹](#åœ¨-threadpool-ä¸­åˆ›å»ºå¤šä¸ªçº¿ç¨‹)
  - [å›åˆ° GeoServer](#å›åˆ°-geoserver)

## æµ‹è¯•é©±åŠ¨å¼€å‘å¤šçº¿ç¨‹åº”ç”¨çš„æ ¸å¿ƒæ¦‚å¿µ

1. **åˆ†ç¦»çº¿ç¨‹é€»è¾‘å’Œç¨‹åºé€»è¾‘**ï¼šæœ€å¥½çš„é¢å‘å¯¹è±¡çš„è®¾è®¡æ˜¯å°½å¯èƒ½åœ°åˆ†ç¦»å„ç§å…³æ³¨ç‚¹ã€‚å¤šçº¿ç¨‹åº”ç”¨ç¨‹åºè®¾è®¡ä¹Ÿä¸ä¾‹å¤–ã€‚å¤šçº¿ç¨‹æ˜¯ä¸€ä¸ªå…³æ³¨ç‚¹ï¼Œåº”ç”¨ç¨‹åºé€»è¾‘æ˜¯å¦ä¸€ä¸ªå…³æ³¨ç‚¹ã€‚è¦å°½å¯èƒ½åœ°åˆ†ç¦»è¿™äº›å…³æ³¨ç‚¹ï¼Œå¹¶å°†è€¦åˆé™åˆ°æœ€ä½ã€‚

2. **ä¼‘çœ æ–¹æ¡ˆå¾ˆç³Ÿç³•**ï¼šåœ¨çº¿ç¨‹ä¸­é€šè¿‡è°ƒç”¨sleep_for()æš‚åœæ‰§è¡Œï¼Œç›´åˆ°æ»¡è¶³ç›¸åº”çš„æ¡ä»¶ï¼Œè¿™ç§æ–¹æ¡ˆå¾ˆç³Ÿç³•ã€‚æµ‹è¯•çš„è¿è¡Œä¼šå˜æ…¢ï¼Œè¿˜ä¼šå¼•å‘éšæœºé”™è¯¯ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼ŒçœŸæ­£çš„é—®é¢˜ä¼šè¢«éšè—å¾—æ›´æ·±ã€æ›´ä¹…ã€‚

3. **ç®€åŒ–ç‰¹å®šçš„åº”ç”¨æµ‹è¯•è‡³å•çº¿ç¨‹**ï¼šåœ¨å¼•å…¥å¤šçº¿ç¨‹ä¹‹å‰ï¼Œåº”ç”¨ç¨‹åºä»£ç é¦–å…ˆç¡®ä¿å¿…é¡»èƒ½å¤Ÿå†å•çº¿ç¨‹ç¯å¢ƒä¸‹å·¥ä½œã€‚ä¸ºç‰¹å®šçš„åº”ç”¨æµ‹è¯•æä¾›æ¶ˆé™¤å¹¶å‘æ€§çš„æ–¹æ³•ï¼Œå¯ä»¥å¸®åŠ©ä½ ä¿æŒæ¸…é†’ã€‚æµ‹è¯•å¤šçº¿ç¨‹å¾€å¾€æœ€ç»ˆä¼šäº§ç”Ÿé€Ÿåº¦è¾ƒæ…¢çš„é›†æˆæµ‹è¯•é¢†åŸŸã€‚

4. **åœ¨å¼•å…¥å¹¶å‘æ€§æ§åˆ¶ä¹‹å‰ï¼ŒéªŒè¯å¹¶å‘æ€§é—®é¢˜**ï¼šåœ¨ç¨‹åºä¸­æ»¥ç”¨å¹¶å‘æ§åˆ¶ï¼ˆLock å’Œ Wait å³ åŒæ­¥ï¼‰ä¼šæå¤§é™ä½åº”ç”¨ç¨‹åºçš„æ€§èƒ½ï¼Œç”šè‡³æœ‰å¯èƒ½è§£å†³ä¸äº†ä»»ä½•çœŸæ­£çš„å¹¶å‘æ€§é—®é¢˜ã€‚æ¥ä¸‹æ¥çš„ç¤ºä¾‹ç¨‹åºä¸»è¦åŒ…å«äº†ä»¥ä¸‹æ ¸å¿ƒå†…å®¹ï¼šå…ˆç¼–å†™ä¸€ä¸ªå¯ä»¥æ¼”ç¤ºæ½œåœ¨å¹¶å‘æ€§é—®é¢˜çš„æµ‹è¯•ï¼›`ç„¶åä½¿å…¶æ¶åŒ–ï¼Œç›´åˆ°æµ‹è¯•æ¯æ¬¡éƒ½ä¼šå¤±è´¥ã€‚`é€šè¿‡æ¼”ç¤ºè¿™äº›å¤±è´¥ï¼Œé¦–å…ˆèƒ½ç¡®ä¿ç»§ç»­ä¿æŒæµ‹è¯•é©±åŠ¨çš„æ¨¡å¼ã€‚ä½ éœ€è¦åšçš„ä»…ä»…æ˜¯å¢åŠ å¹¶å‘æ€§æ§åˆ¶ï¼Œä»¥ä¾¿æµ‹è¯•å¯ä»¥é€šè¿‡ã€‚

## ç¤ºä¾‹ç¨‹åº GeoServer

GeoServer ä¸ºå®¢æˆ·ç«¯åº”ç”¨ç¨‹åºæä¾›äº†ä¸€äº›æ”¯æŒï¼Œä»¥è·Ÿè¸ªå¤§é‡ç”¨æˆ·çš„åœ°ç†ä½ç½®å…¸å‹çš„å®¢æˆ·ç«¯åº”ç”¨æ˜¯åŸºäºåœ°å›¾çš„æ‰‹æœºåº”ç”¨ç¨‹åºã€‚

> ç‰ˆæœ¬ï¼šd7ea5c555dd8f1a4fb8d3c832fe4331937721f5b

[GerServer æºç ](https://github.com/HATTER-LONG/TDD_Learning/tree/master/Src/GeoServer)

åŸºäºè¿™äº›åŸºæœ¬æºç ç´ æï¼Œæ–°å¢éœ€æ±‚ï¼š

åœºæ™¯ï¼šæœç´¢é™„è¿‘çš„ç”¨æˆ·
> ä½œä¸ºå®¢æˆ·ç«¯ç”¨æˆ·ï¼Œæˆ‘å¸Œæœ›èƒ½å¤Ÿæ ‡è¯†å‡ºåœ°å›¾ä¸ŠæŸä¸ªçŸ©å½¢åŒºåŸŸå†…çš„æ‰€æœ‰ç”¨æˆ·ï¼ˆåŒ…æ‹¬ä»–ä»¬çš„åæ ‡ï¼‰ï¼Œè¿™æ ·å°±èƒ½çŸ¥é“ä»–ä»¬åœ¨åœ°å›¾ä¸Šçš„ä½ç½®äº†

æˆ‘ä»¬å°†åœ¨ GeoServer ä¸­å®ç°è¿™ä¸€ç‚¹ã€‚å…¶ä¸­ Area è¡¨ç¤ºä»¥æŸä¸ªä½ç½®ä¸ºä¸­å¿ƒçš„çŸ©å½¢åŒºåŸŸï¼Œèƒ½å¤Ÿè¡¨æ˜è¯¥åŒºåŸŸæ˜¯å¦åŒ…å«äº†ä¸€ä¸ªï¼ˆæˆ–å…¶ä»–ï¼‰ä½ç½®ã€‚
> ç‰ˆæœ¬ï¼š92321c96a0d4a56bbf4e731898a966a718bf2d4c

## æ€§èƒ½è¦æ±‚

æˆ‘ä»¬é¢ä¸´æ€§èƒ½æ–¹é¢çš„è€ƒéªŒã€‚äº§å“è´Ÿè´£äººæŒ‡å‡ºæˆ‘ä»¬æœŸæœ›å¤§é‡çš„ç”¨æˆ·ã€‚åˆå§‹å‘è¡Œç‰ˆæœ¬åº”è¯¥å¯ä»¥åŒæ—¶æ”¯æŒ50 000ä½ç”¨æˆ·ã€‚

ç¼–å†™ä»¥ä¸‹æµ‹è¯•ç”¨æ¥æ¨¡æ‹Ÿå°†ç”¨æˆ·æ•°ç›®é€æ­¥å¢å€¼å·¨å¤§æ•°é‡çº§ï¼š

> ç‰ˆæœ¬ï¼š85e7273736f1b3b6180ef0fff62622f7ffba82eb

```cpp
TEST_CASE_METHOD(FixtureUserInBox, "Handles large numbers of users", "[AGeoServer_UsersInBox]")
{
    Location anotherLocation { aUserLocation.go(10, West) };
    const unsigned int lots { 500000 };
    for (unsigned int i { 0 }; i < lots; i++)
    {
        string user { "user" + to_string(i) };
        server.track(user);
        server.updateLocation(user, anotherLocation);
    }

    auto users = server.usersInBox(aUser, Width, Height);
    REQUIRE(lots == users.size());
}
```

å¯ä»¥å‘ç°åœ¨æ‰§è¡Œæ­¤æµ‹è¯•ä¼šæœ‰æ˜æ˜¾çš„æ—¶é—´æ¶ˆè€—ï¼š

```shell
~
â¯ /home/caolei/WorkSpace/TDD_Learning/build/test/catch2_GeoServerTest -d yes
0.000 s: Tracks m_aUser
0.000 s: Is not tracking m_aUser not tracked
0.000 s: Tracks multiple users
0.000 s: Is tracking answers false when user no longer tracked
0.000 s: Updates location of user
0.000 s: Answers unknown location for user not tracked
0.000 s: Answers unknown location for tracked user with no location update
0.000 s: Answers unknown location for user no longer tracked
0.000 s: Answers users in specified range
0.000 s: Answers only users within specified range
0.580 s: Handles large numbers of users
===============================================================================
All tests passed (14 assertions in 11 test cases)
```

è™½ç„¶çœ‹èµ·æ¥å¹¶ä¸é•¿ï¼Œä½†è¿™ä»…ä»…åªæ˜¯ä¸€ä¸ªæµ‹è¯•ã€‚ä¸€ä¸ªç³»ç»Ÿä¸­æœ€ç»ˆå¯èƒ½ä¼šæœ‰æˆåƒä¸Šä¸‡ä¸ªæµ‹è¯•ï¼Œå³ä¾¿åªæœ‰å°‘é‡è¿è¡Œç¼“æ…¢çš„æµ‹è¯•ï¼Œä½†ä¹Ÿä¼šé˜»ç¢ä½ æŒ‰ç…§å¿…è¦çš„é¢‘ç‡æ¥è¿è¡Œè¿™äº›æµ‹è¯•ã€‚ã€‚æˆ‘ä»¬å¹¶ä¸æƒ³åœ¨å¿«é€Ÿæµ‹è¯•é›†ä¸­è¿è¡Œè¾ƒæ…¢çš„ HandlesLargeNumbersOfUsers æµ‹è¯•ã€‚ä½†æˆ‘ä»¬å°†æ¥ä»ç„¶æœ‰å¯èƒ½éœ€è¦è¿è¡Œå®ƒã€‚å®Œæˆæ¸…ç†å·¥ä½œä¹‹åï¼Œæœ€å¥½çš„æªæ–½å°±æ˜¯å°† HandlesLargeNumbersOfUsers ç§»åˆ°è¿è¡Œè¾ƒæ…¢çš„å…¶ä»–æµ‹è¯•é›†ä¸­ã€‚

ä½†æ˜¯æˆ‘ä»¬æœ€å¥½ç¡®å®šæ˜¯ä»€ä¹ˆå¯¼è‡´æµ‹è¯•è¿è¡Œç¼“æ…¢ï¼š

```cpp
TEST_CASE_METHOD(FixtureUserInBox, "Handles large numbers of users",
    "[.][Slow][AGeoServer_UsersInBox_Slow][AGeoServer_UsersInBox]")
{
    Location anotherLocation { aUserLocation.go(10, West) };
    const unsigned int lots { 500000 };
    for (unsigned int i { 0 }; i < lots; i++)
    {
        string user { "user" + to_string(i) };
        server.track(user);
        server.updateLocation(user, anotherLocation);
    }
    ToolBox::TestTimer testtimer;
    auto users = server.usersInBox(aUser, Width, Height);

    REQUIRE(lots == users.size());
}
```

```shell
~
â¯ /home/caolei/WorkSpace/TDD_Learning/build/test/catch2_GeoServerTest -s  -d yes "[AGeoServer_UsersInBox_Slow]"
Filters: [AGeoServer_UsersInBox_Slow]

........

catch2_GeoServerTest elapsed time = 133.654ms
0.582 s: Handles large numbers of users
===============================================================================
All tests passed (1 assertion in 1 test case)
```

è™½ç„¶ 133 æ¯«ç§’æ²¡æœ‰åŠç§’é‚£ä¹ˆä¸¥é‡ï¼Œä½†äº§å“è´Ÿè´£äººå¯¹æ­¤å¹¶ä¸æ»¡æ„ã€‚æˆ‘ä»¬å’Œå¥¹è®¨è®ºå„ç§å¯è¡Œæ–¹æ¡ˆï¼Œä¸€èµ·æ„é€ å‡ºä¸€ä¸ªå¯ä»¥æ»¡è¶³éœ€æ±‚çš„åœºæ™¯ã€‚

åœºæ™¯ï¼šæœç´¢é™„è¿‘ç”¨æˆ·æ˜¯ä¸€ä¸ªå¼‚æ­¥çš„éœ€æ±‚
>ä½œä¸ºå®¢æˆ·ç«¯ç”¨æˆ·ï¼Œæˆ‘æœŸæœ›â€œæœç´¢é™„è¿‘ç”¨æˆ·â€çš„éœ€æ±‚èƒ½å¤Ÿè¿…é€Ÿå¾—åˆ°åé¦ˆã€‚æˆ‘æƒ³é€ä¸ªåœ°æ”¶åˆ°é™„è¿‘ç”¨æˆ·çš„ä¿¡æ¯ï¼Œæ¯æ”¶åˆ°ä¸€ä¸ªå°±åœ¨åœ°å›¾ä¸Šæ˜¾ç¤ºå‡ºæ¥ã€‚

ä½ å¯èƒ½å·²ç»æ„è¯†åˆ°è¿™äº›åœºæ™¯å¹¶éæ˜¯æŠ€æœ¯ä¸Šçš„ã€‚ç°å­˜çš„æŒ‡å¯¼æ–¹é’ˆå°†é¿å…åˆ›å»ºä¸å¯¹å•†ä¸šæä¾›å¯éªŒè¯ä»·å€¼çš„åœºæ™¯ã€‚

## è®¾è®¡å¼‚æ­¥æ–¹æ¡ˆ

GeoServerå®¢æˆ·ç«¯éœ€è¦ç®€å•çš„æ¥å£ï¼Œç”¨äºå°†ç”¨æˆ·ä¿¡æ¯ã€é«˜åº¦ã€å®½åº¦ä¼ é€ç»™æœåŠ¡å™¨ï¼Œå¹¶ä»æœåŠ¡å™¨å¾—åˆ°ç”¨æˆ·æ¸…å•ã€‚ç„¶è€Œï¼Œä¸ºäº†æ”¯æŒå¼‚æ­¥çš„ç”¨æˆ·ä½“éªŒï¼Œå®¢æˆ·ç«¯éœ€è¦å‘æœåŠ¡å™¨ç«¯ä¼ é€’ä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œä»¥ä¾¿å¤„ç†æŸä¸ªåŒºåŸŸå†…æ¥å—çš„æ‰€æœ‰ç”¨æˆ·ä¿¡æ¯ã€‚

æƒ³è¦åˆ†ç¦»å®¢æˆ·ç«¯å’Œå¤šçº¿ç¨‹çš„å®ç°ç»†èŠ‚ï¼Œä»¥ä¸‹æ˜¯æˆ‘ä»¬æè®®çš„è®¾è®¡æ€è·¯ï¼š

1. ä¸ºæ¯ä¸€ä¸ªè¿æ¥éœ€æ±‚åˆ›å»ºä¸€ä¸ªå·¥ä½œé¡¹ï¼Œå¹¶å°†å…¶åŠ å…¥åˆ°å·¥ä½œé˜Ÿåˆ—ä¸­ã€‚è¯¥å·¥ä½œé¡¹åŒ…å«äº†ç”¨æ¥åˆ¤æ–­ç”¨æˆ·æ˜¯å¦å¤„åœ¨æŸä¸ªåŒºåŸŸå†…çš„æ‰€æœ‰ä¿¡æ¯ã€‚
2. åœ¨ GeoServer ç«¯å¯åŠ¨ä¸€ä¸ªæˆ–å¤šä¸ªå·¥ä½œçº¿ç¨‹ã€‚å¤„äºç©ºé—²çŠ¶æ€çš„å·¥ä½œçº¿ç¨‹ä¼šç­‰å¾…å·¥ä½œé˜Ÿåˆ—ä¸­å¯ç”¨çš„å·¥ä½œé¡¹ã€‚ä¸€æ—¦æŠ“å–äº†ä¸€ä¸ªå·¥ä½œé¡¹ï¼Œå·¥ä½œçº¿ç¨‹å°±ä¼šå¼€å§‹å¤„ç†è¯¥å·¥ä½œé¡¹ã€‚

åŸºäºä»¥ä¸Šè®¾è®¡æ€è·¯ï¼Œå¯ä»¥ç›´æ¥åœ¨ GeoServer ç±»ä¸­è¿›è¡Œç¼–ç ï¼Œä½†è¿™ä¼šå°†å¤šçº¿ç¨‹å’Œåº”ç”¨ç¨‹åºé€»è¾‘æ‚ç³…ï¼Œä¸€æ—¦å‡ºç°é—®é¢˜ï¼ŒDebug çš„è¿‡ç¨‹å°†ä¼šå¾ˆç—›è‹¦ã€‚

æˆ‘ä»¬å¯ä»¥åˆ†ç¦»æ¶‰åŠçš„ä¸‰ä¸ªå…³æ³¨ç‚¹ï¼š

1. Work ç±»ï¼Œè¡¨ç¤ºä¸€ä¸ªå·¥ä½œé¡¹ï¼›
2. ThreadPool ç±»ï¼Œç”¨äºåˆ›å»ºå·¥ä½œçº¿ç¨‹å¹¶å¤„ç†å·¥ä½œé˜Ÿåˆ—ï¼›
3. GeoServer ç±»ï¼Œç”¨äºåˆ›å»º Work å¯¹è±¡ï¼Œå¹¶å°†å…¶å‘é€åˆ° ThreadPool ä»¥ä¾¿è®©å…¶æ‰§è¡Œã€‚

å…ˆä»æœ€ç®€å•çš„ Work ç±»å¼€å§‹ï¼š

> ç‰ˆæœ¬ï¼š72a172fa373662efb9ac8126b1e65be2404bf861

```cpp
#pragma once
#include <functional>

class Work
{
public:
    static const int DefaultId { 0 };
    Work(int id = DefaultId)
            : m_id { id }
            , m_executeFunction { [] {} }
    {
    }

    Work(std::function<void()> executeFunction, int id = DefaultId)
            : m_id { id }
            , m_executeFunction { executeFunction }
    {
    }
    void execute() { m_executeFunction(); }
    int id() const { return m_id; }

private:
    int m_id;
    std::function<void()> m_executeFunction;
};
```

ä»£ç å¾ˆç®€å•ï¼ŒåŒæ—¶ä¹Ÿæœ‰æ›´å…·ä½“çš„å•å…ƒæµ‹è¯•æ ‡è¯†ä½¿ç”¨æ–¹æ³•ã€‚

## ä¾ç„¶ç®€å•çš„æµ‹è¯•é©±åŠ¨

æ¥ä¸‹æ¥ç€æ‰‹æ¶‰åŠ ThreadPool ç±»ï¼Œåœ¨å¼•å…¥å¤šçº¿ç¨‹å‰ï¼Œå…ˆé€šè¿‡æµ‹è¯•é©±åŠ¨å¼€å‘ä¸€äº›å¤„ç†ç”¨æˆ·éœ€æ±‚çš„æ¨¡å—ã€‚

> ç‰ˆæœ¬ï¼š4c188cd300678c630605b52bcae0eb4819af60ff

```cpp
//ThreadPool.h
#pragma once

#include "Work.h"

#include <deque>
#include <string>

class ThreadPool
{
public:
    bool hasWork() { return !workQueue_.empty(); }

    void add(Work work) { workQueue_.push_front(work); }

    Work pullWork()
    {
        auto work = workQueue_.back();
        workQueue_.pop_back();
        return work;
    }

private:
    std::deque<Work> workQueue_;
};
```

æµ‹è¯•ä»£ç è¯¦è§ [ThreadPoolTest.cpp](https://github.com/HATTER-LONG/TDD_Learning/blob/master/test/Catch2/GeoServerTest/ThreadPoolTest.cpp)

## ä¸ºå¤šçº¿ç¨‹åšå¥½å‡†å¤‡

ç°åœ¨çš„ç›®æ ‡æ˜¯è®© ThreadPool å¤„ç†æŠ“å–å¹¶æ‰§è¡Œå·¥ä½œé¡¹ã€‚ç°åœ¨éœ€è¦ä¸€ä¸ªçº¿ç¨‹ã€‚åˆ›å»ºä¸€ä¸ªæµ‹è¯•æ¥å°† WorK å¯¹è±¡å‘é€åˆ° ThreadPool ä¸­ï¼Œå¹¶è®©çº¿ç¨‹æ± å¼‚æ­¥åœ°å¤„ç† Work å¯¹è±¡ã€‚

```cpp
TEST_CASE_METHOD(Fixture, "Pulls work in a thread", "[AThreadPool]")
{
    ThreadPool pool2;
    condition_variable wasExecuted;
    bool wasWorked { false };
    Work work { [&] {
        unique_lock<mutex> lock(m);
        wasWorked = true;
        wasExecuted.notify_all();
    } };
    pool2.add(work);

    unique_lock<mutex> lock(m);
    REQUIRE(wasExecuted.wait_for(lock, chrono::milliseconds(100), [&] { return wasWorked; }));
}
```

é‡‡å–äº† wait/notify çš„ç­–ç•¥ã€‚å½“åˆ›å»ºå®Œä¸€ä¸ª ThreadPool çš„å®ä¾‹åï¼Œæµ‹è¯•ç¨‹åºå®šä¹‰äº†ä¸€ä¸ªæ¡ä»¶å˜é‡ wasExecutedã€‚è¿™ä¸ªä¿¡å·é‡å¯ä»¥é¿å…æµ‹è¯•è¿‡å¿«å®Œæˆã€‚æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªå·¥ä½œé¡¹ï¼Œè¯¥å·¥ä½œé¡¹ä¸­çš„å›è°ƒå‡½æ•°å¯ä»¥è®¾ç½®æ ‡å¿—ä½ï¼Œå¹¶é€šçŸ¥æ‰€æœ‰ç­‰å¾… wasExecuted æ¡ä»¶çš„çº¿ç¨‹ã€‚æˆ‘ä»¬æœŸæœ› ThreadPool çš„å·¥ä½œçº¿ç¨‹æ¥æ‰§è¡Œè¿™ä¸ªå·¥ä½œé¡¹ã€‚æµ‹è¯•è°ƒç”¨ pool.add(work) åï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ªäº’æ–¥é”ï¼Œå¹¶ä¸€ç›´ç­‰åˆ°ç›¸åº”çš„æ ‡å¿—ä½è¢«è®¾ç½®ã€‚å¦‚æœæ²¡æœ‰åŠæ—¶æ¸…é™¤æ¡ä»¶
å˜é‡ï¼Œé‚£ä¹ˆæµ‹è¯•å°†ä¼šå¤±è´¥ã€‚

åœ¨ ThreadPool ç±»ä¸­å¢åŠ å‡½æ•° start() ç”¨æ¥å†³å®šï¼šå®¢æˆ·ç«¯ç¨‹åºå¿…é¡»è¡¨æ˜ ThreadPool åº”è¯¥åœ¨ä»€ä¹ˆæ—¶å€™å¯åŠ¨å®ƒçš„å·¥ä½œçº¿ç¨‹ã€‚å› ä¸ºçº¿ç¨‹ä¸ä¼šåœ¨ ThreadPool å®ä¾‹åŒ–çš„è¿‡ç¨‹ä¸­è‡ªåŠ¨å¯åŠ¨ï¼Œæ‰€ä»¥ï¼Œå¯¹äºä¹‹å‰ç¼–å†™çš„åŸºäºç‰¹å®šåº”ç”¨ç¨‹åºçš„æµ‹è¯•ï¼Œæˆ‘ä»¬æ— éœ€æ‹…å¿ƒå¤šçº¿ç¨‹çš„é—®é¢˜ã€‚å‡½æ•° start() å¯åŠ¨äº†ä¸€ä¸ªå·¥ä½œçº¿ç¨‹ï¼Œä¸€æ—¦è¯¥çº¿ç¨‹å®Œæˆåˆå§‹åŒ–ï¼Œåœ¨ææ„å‡½æ•°ä¸­å°†ä¼šè°ƒç”¨ join()ã€‚

> ç‰ˆæœ¬ï¼š8d7e785965e43dc80e1e0573d8d9bb472653df51

```cpp
//ThreadPool.h

#pragma once

#include "Work.h"

#include <deque>
#include <memory>
#include <string>
#include <thread>
class ThreadPool
{
public:
    virtual ~ThreadPool()
    {
        if (workThread_)
            workThread_->join();
    }

    void start() { workThread_ = std::make_shared<std::thread>(&ThreadPool::worker, this); }
    bool hasWork() { return !workQueue_.empty(); }

    void add(Work work) { workQueue_.push_front(work); }

    Work pullWork()
    {
        auto work = workQueue_.back();
        workQueue_.pop_back();
        return work;
    }

private:
    void worker()
    {
        while (!hasWork())
            ;
        pullWork().execute();
    }


private:
    std::deque<Work> workQueue_;
    std::shared_ptr<std::thread> workThread_;
};
```

```shell
~
â¯ /home/caolei/WorkSpace/TDD_Learning/build/test/catch2_GeoServerTest
terminate called after throwing an instance of 'std::system_error'
  what():  Invalid argument

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
catch2_GeoServerTest is a Catch v2.13.3 host application.
Run with -? for options

-------------------------------------------------------------------------------
Pulls work in a thread
-------------------------------------------------------------------------------
/home/caolei/WorkSpace/TDD_Learning/test/Catch2/GeoServerTest/ThreadPoolTest.cpp:69
...............................................................................

/home/caolei/WorkSpace/TDD_Learning/test/Catch2/GeoServerTest/ThreadPoolTest.cpp:69: FAILED:
due to a fatal error condition:
  SIGABRT - Abort (abnormal termination) signal

===============================================================================
test cases: 17 | 16 passed | 1 failed
assertions: 20 | 19 passed | 1 failed

[1]    21144 abort (core dumped)  /home/caolei/WorkSpace/TDD_Learning/build/test/catch2_GeoServerTest

~
â¯ /home/caolei/WorkSpace/TDD_Learning/build/test/catch2_GeoServerTest
===============================================================================
All tests passed (25 assertions in 24 test cases)

```

å¯ä»¥å‘ç°æµ‹è¯•æœ‰æ—¶èƒ½æˆåŠŸï¼Œ**æˆ‘ä»¬å°†ç ”ç©¶å¦ä¸€ä¸ªæ–¹æ¡ˆï¼šç”¨å¼ºåˆ¶æ‰‹æ®µè®©é”™è¯¯ç›´æ¥æºäºæµ‹è¯•æœ¬èº«ã€‚**

## æš´éœ²å¹¶å‘æ€§é—®é¢˜

æˆ‘ä»¬æƒ³è¿›ä¸€æ­¥å±•ç¤ºï¼šå·¥ä½œçº¿ç¨‹å¯ä»¥ä»å·¥ä½œé˜Ÿåˆ—ä¸­æŠ“å–å’Œæ‰§è¡Œå¤šä¸ªå·¥ä½œé¡¹ã€‚

```cpp
TEST_CASE_METHOD(Fixture, "Executest all work", "[AThreadPool]")
{
    ThreadPool pool2;
    pool2.start();
    unsigned int count { 0 };
    unsigned int NumberOfWorkItems { 3 };

    condition_variable wasExecuted;
    Work work { [&] {
        std::unique_lock<std::mutex> lock(m);
        ++count;
        wasExecuted.notify_all();
    } };

    for (unsigned int i { 0 }; i < NumberOfWorkItems; i++)
        pool2.add(work);
    unique_lock<mutex> lock(m);
    REQUIRE(
        wasExecuted.wait_for(lock, chrono::milliseconds(100), [&] { return count == NumberOfWorkItems; }));
}
```

å®ç°ä¸­å¼•å…¥äº†ä¸€ä¸ª while å¾ªç¯ã€ä¸€ä¸ªå¸ƒå°”é‡æ ‡å¿—ä½ï¼Œåœ¨é”€æ¯ ThreadPool å®ä¾‹çš„æ—¶å€™ï¼Œåœæ­¢æ‰§è¡Œ while å¾ªç¯ã€‚

```cpp
class ThreadPool
{
public:
    virtual ~ThreadPool()
    {
        done_ = true;
        if (workThread_)
            workThread_->join();
    }
......

private:
    void worker()
    {
        while (!done_)
        {
            while (!hasWork())
                ;
            pullWork().execute();
        }
    }


private:
    std::atomic<bool> done_ { false };
    std::deque<Work> workQueue_;
    std::shared_ptr<std::thread> workThread_;
};
```

è¿™ä¸ªå®ç°å­˜åœ¨é—®é¢˜ï¼Œå½“æµ‹è¯•å®Œæˆåï¼ŒThreadPool çš„ææ„å‡½æ•°å°†æ ‡å¿—ä½ done_ è®¾ä¸º trueï¼Œå¹¶å°è¯•åŠ å…¥çº¿ç¨‹æ‰§è¡Œã€‚è€Œçº¿ç¨‹å´æ— æ³•å®Œæˆå·¥ä½œï¼Œå› ä¸ºå®ƒä¸€ç›´é™·åœ¨ while å¾ªç¯ä¸­ï¼Œç­‰å¾…å¯ç”¨çš„å·¥ä½œé¡¹ã€‚

```cpp
    void worker()
    {
        while (!done_)
        {
            while (!done_ && !hasWork())
                ;
            if (done_)
                break;
            pullWork().execute();
        }
    }
```

å¤šæ¬¡å°è¯•åï¼Œä¾æ—§æ˜¯æœ‰æ—¶æˆåŠŸæœ‰æ—¶å¤±è´¥ã€‚ç»è¿‡ä»¥ä¸Šçš„å°è¯•åå‘ç°ï¼Œå¢åŠ å¾ªç¯ä¸­çš„å·¥ä½œé¡¹æ•°ç›®å¹¶ä¸ä¼šå¸¦æ¥ä»€ä¹ˆå·®åˆ«ã€‚æµ‹è¯•éœ€è¦ä»æœ¬èº«åˆ›å»ºçš„çº¿ç¨‹ä¸­å¢åŠ å·¥ä½œé¡¹ã€‚

## åœ¨æµ‹è¯•ä¸­åˆ›å»ºå®¢æˆ·ç«¯çº¿ç¨‹

è¿™æ¬¡æˆ‘ä»¬å‡è®¾é”™è¯¯æ˜¯ç”±å›´ç»•å·¥ä½œé˜Ÿåˆ—äº‰å¤ºæ•°æ®é€ æˆçš„ã€‚ä¸»çº¿ç¨‹å°†å·¥ä½œé¡¹åŠ å…¥åˆ°å·¥ä½œé˜Ÿåˆ—ä¸­ï¼Œå‡½æ•° pullWork() å°†å·¥ä½œé¡¹ä»é˜Ÿåˆ—ä¸­ç§»é™¤ï¼Œä¸”å·¥ä½œçº¿ç¨‹ä¸æ–­æŸ¥è¯¢å·¥ä½œé˜Ÿåˆ—ä¸­æ˜¯å¦æœ‰å¯ç”¨çš„å·¥ä½œé¡¹ã€‚

æˆ‘ä»¬çš„æµ‹è¯•ä¸æ˜¯ç®€å•çš„å¤±è´¥ï¼Œè€Œæ˜¯ä¼šå¯¼è‡´åˆ†æ®µé”™è¯¯ã€‚å·¥ä½œé˜Ÿåˆ—çš„å¹¶è¡Œæ›´æ–°çœ‹èµ·æ¥æ˜¯ä¸€ä¸ªç–‘ç‚¹ã€‚ä¸ºäº†ä¿®è¡¥è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å…ˆç¼–å†™ä¸€ä¸ªå¯ä»¥ç¨³å®šäº§ç”ŸåŒæ ·é”™è¯¯çš„æµ‹è¯•ã€‚

> ç‰ˆæœ¬ï¼šc2326e835bd8446acbd740e8f73963a214ff79fd

```cpp
class Fixture_Thread
{
public:
    ~Fixture_Thread()
    {
        for (auto& t : threads)
            t->join();
    }
    void incrementCountAndNotify()
    {
        std::unique_lock<std::mutex> lock(m);
        ++count;
        wasExecuted.notify_all();
    }

    void waitForCountAndFailOnTimeout(
        unsigned int expectedCount, const milliseconds& time = milliseconds(100))
    {
        unique_lock<mutex> lock(m);
        REQUIRE(wasExecuted.wait_for(lock, time, [&] { return expectedCount == count; }));
    }

    mutex m;
    condition_variable wasExecuted;
    unsigned int count { 0 };

    vector<shared_ptr<thread>> threads;
};

TEST_CASE_METHOD(Fixture_Thread, "Executest all work", "[AThreadPool_AddRequest]")
{
    ThreadPool pool2;
    pool2.start();

    Work work { [&] { incrementCountAndNotify(); } };
    unsigned int NumberOfWorkItems { 100 };
    unsigned int NumberOfThreads { 100 };

    for (unsigned int i { 0 }; i < NumberOfThreads; i++)
        threads.push_back(make_shared<thread>([&] {
            for (unsigned int j { 0 }; j < NumberOfWorkItems; j++)
                pool2.add(work);
        }));
    waitForCountAndFailOnTimeout(NumberOfThreads * NumberOfWorkItems);
}
```

æµ‹è¯•é€šè¿‡ for å¾ªç¯æ¥åˆ›å»ºä»»æ„æ•°ç›®çš„å·¥ä½œçº¿ç¨‹ã€‚å°† NumberOfThreads å’Œ NumberOfWorkItems è®¾ä¸º100ï¼Œç„¶åå‡ºç°äº†åŒæ ·çš„é—´æ­‡æ€§é”™è¯¯ã€‚

æ¥ä¸‹æ¥åœ¨å‡½æ•° hasWork()ã€add() å’Œ pullWork() ä¸­åŠ å…¥é”ä¿æŠ¤ã€‚

```cpp
bool hasWork()
    {
        std::lock_guard<std::mutex> block(mutex_);
        return !workQueue_.empty();
    }
```

æœ€ç»ˆæµ‹è¯•å¯ä»¥æ­£ç¡®é€šè¿‡ã€‚

## åœ¨ ThreadPool ä¸­åˆ›å»ºå¤šä¸ªçº¿ç¨‹

å°±è¿™æ ·ç»“æŸäº†å—ï¼Ÿå·²ç»è§£å†³äº†æ‰€æœ‰çš„å¹¶å‘æ€§æ¼æ´å—ï¼Ÿä¸ºäº†æ‰¾å‡ºé—ç•™çš„é—®é¢˜ï¼Œä¸€ç§åˆ†ææ–¹æ³•æ˜¯æƒ³æƒ³ä»»ä½•å­˜åœ¨çš„ç¼ºå£ã€‚ç¼ºå£æ˜¯æŒ‡ï¼Œæˆ‘ä»¬åŸºäºæŸä¸ªâ€œäº‹å®â€åšäº†ä¸€äº›å‡è®¾ï¼Œä½†å› ä¸ºå…¶ä»–å¤±æ§çº¿ç¨‹çš„å¹²æ‰°ï¼Œè¿™ä¸ªâ€œäº‹å®â€å¹¶ä¸æˆç«‹ã€‚

worker() å‡½æ•°çœ‹èµ·æ¥æ˜¯å”¯ä¸€å¯èƒ½åŒ…å«æœ‰æ½œåœ¨é£é™©ä»£ç çš„å‡½æ•°ã€‚åœ¨ worker() å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬è½®è¯¢å¯ç”¨çš„å·¥ä½œé¡¹ï¼Œæ¯æ¬¡éƒ½æ˜¯é€šè¿‡å¾ªç¯æ¥å»ºç«‹ã€é‡Šæ”¾ hasWork() ä¸­çš„ä¸€ä¸ªé”ã€‚ä¸€æ—¦æœ‰å¯ç”¨çš„å·¥ä½œé¡¹ï¼Œå¾ªç¯é€€å‡ºï¼Œæ§åˆ¶æƒç§»äº¤ç»™pullWork().execute()ã€‚è®¾æƒ³ä¸€ä¸‹ï¼Œå¦‚æœåœ¨è¿™ä¸ªæä¸ºçŸ­æš‚çš„æ—¶é—´æ®µé‡Œï¼Œå…¶ä»–çš„çº¿ç¨‹æŠ“å–äº†å¯ç”¨å·¥ä½œé¡¹ï¼Œé‚£ä¹ˆä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿ

ç›®å‰ï¼ŒThreadPool ä»…ä»…ç®¡ç†ä¸€ä¸ªçº¿ç¨‹ï¼Œè¿™æ„å‘³ç€ worker() å‡½æ•°é€šè¿‡ä¸²è¡Œçš„æ–¹å¼ï¼Œä¸€ä¸ªæ¥ä¸€ä¸ªåœ°æŠ“å–å¹¶æ‰§è¡Œå¯é€‰å·¥ä½œé¡¹ï¼Œæ²¡æœ‰æœºä¼šå¼•å‘å¹¶å‘æ€§çš„é—®é¢˜ã€‚æˆ‘ä»¬åœ¨ ThreadPool ä¸­åŠ å…¥å¯¹çº¿ç¨‹æ± çš„æ”¯æŒï¼Œè®©å…¶åå‰¯å…¶å®ã€‚

> ç‰ˆæœ¬ï¼š1e6dd55d7ea3ae0e38f3d1667861f20bba3c489f (æ³¨æ„æäº¤ä¸­çš„é”™è¯¯ï¼Œè¯¦è§ä¸‹æ–¹ä»£ç æ³¨é‡Š)

```cpp
class Fixture_MultipleThread : public Fixture_Thread
{
public:
    set<thread::id> threads;

    void addThreadIfUnique(const thread::id& id)
    {
        std::unique_lock<std::mutex> lock(m);
        threads.insert(id);
    }

    size_t numberOfThreadsProcessed() { return threads.size(); }
};

TEST_CASE_METHOD(Fixture_MultipleThread, "DispatchesWorkToMultipleThreads", "[AThreadPoolWithMultipleThread]")
{
    ThreadPool pool2;
    //æ³¨æ„è¿™æ¡æäº¤çš„ä»£ç ä¸­æœ‰ä¸ªé”™è¯¯ï¼Œå¤šå‡ºäº†ä¸€å¥ start,ä¹Ÿè­¦å‘Šäº†æˆ‘ä»¬ä¸è¦æ‹·è´ä»£ç  ğŸ˜‚
    //pool2.start();
    unsigned int numberOfThreads { 2 };
    pool2.start(numberOfThreads);
    Work work { [&] {
        addThreadIfUnique(this_thread::get_id());
        incrementCountAndNotify();
    } };
    unsigned int NumberOfWorkItems { 500 };

    for (unsigned int i { 0 }; i < NumberOfWorkItems; i++)
        pool2.add(work);

    waitForCountAndFailOnTimeout(NumberOfWorkItems);
    REQUIRE(numberOfThreads == numberOfThreadsProcessed());
}
```

```cpp
class ThreadPool
{
public:
    virtual ~ThreadPool() { stop(); }

    void stop()
    {
        done_ = true;
        for (auto& thread : threads_)
            thread.join();
    }

    void start(unsigned int numberOfThreads = 1)
    {
        for (unsigned int i { 0u }; i < numberOfThreads; i++)
            threads_.push_back(std::thread(&ThreadPool::worker, this));
    }
    .......

    Work pullWork()
    {
        std::lock_guard<std::mutex> block(mutex_);

        auto work = workQueue_.back();
        workQueue_.pop_back();
        return work;
    }

private:
    void worker()
    {
        while (!done_)
        {
            while (!done_ && !hasWork())
                ;
            if (done_)
                break;
            pullWork().execute();
        }
    }
....
    std::vector<std::thread> threads_;
};
```

æµ‹è¯•æ€»æ˜¯å¤±è´¥ã€‚è€ƒè™‘åˆ°å¯¹ worker() å‡½æ•°çš„æ€€ç–‘ï¼Œæˆ‘ä»¬å¢åŠ ä¸€è¡Œä»£ç æ¥å¤„ç†å¹¶ä¸å­˜åœ¨çš„å·¥ä½œé¡¹ï¼ˆæ¢å¥è¯è¯´ï¼Œå…¶ä»–çº¿ç¨‹å·²ç»æŠ“å–äº†è¯¥å·¥ä½œé¡¹ï¼‰ã€‚

```cpp
    Work pullWork()
    {
        std::lock_guard<std::mutex> block(mutex_);

        if (workQueue_.empty()) return Work{};
        
        auto work = workQueue_.back();
        workQueue_.pop_back();
        return work;
    }
```

## å›åˆ° GeoServer

æˆ‘ä»¬å·²ç»è®¾è®¡å¹¶å®ç°äº† ThreadPoolï¼Œç°åœ¨å¼€å§‹ä½¿ç”¨è¿™ä¸ªç±»ã€‚ç¬¬ä¸€æ­¥æ˜¯ä¿®æ”¹ usersInBox()ï¼Œå¢åŠ ç›‘å¬æˆ–è€…å›è°ƒå‡½æ•°çš„å‚æ•°ã€‚æ›´æ–°ä»£ç ï¼Œå°† User å¯¹è±¡é€šè¿‡å›è°ƒå‡½æ•°è¿”å›ç»™å®¢æˆ·ç«¯ï¼Œè¿™æ ·å°±å¯ä»¥å¼‚æ­¥åœ°é›†ä¸­è¿™äº›å¯¹è±¡ã€‚

è¿™ä¸€éƒ¨åˆ†å°±æ˜¯å¦‚ä½•ä½¿ç”¨æˆ‘ä»¬å…ˆå‰å¼€å‘å‡ºçš„ ThreadPool äº†ï¼Œè¯¦ç»†çœ‹ä¸‹ä¹¦ä¸­åŸæ–‡å¥½äº†ã€‚
