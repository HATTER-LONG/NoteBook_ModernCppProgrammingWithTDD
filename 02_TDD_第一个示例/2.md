# æµ‹è¯•é©±åŠ¨å¼€å‘ï¼šç¬¬ä¸€ä¸ªç¤ºä¾‹

- [æµ‹è¯•é©±åŠ¨å¼€å‘ï¼šç¬¬ä¸€ä¸ªç¤ºä¾‹](#æµ‹è¯•é©±åŠ¨å¼€å‘ç¬¬ä¸€ä¸ªç¤ºä¾‹)
  - [å‰è¨€](#å‰è¨€)
  - [Soundex ç±»](#soundex-ç±»)
  - [Let's start](#lets-start)
  - [å»æ‰ä¸å¹²å‡€çš„ä»£ç ](#å»æ‰ä¸å¹²å‡€çš„ä»£ç )
    - [å‘½åç©ºé—´çš„ä¿®å¤](#å‘½åç©ºé—´çš„ä¿®å¤)
    - [æ¶ˆé™¤é‡å¤ä»£ç ](#æ¶ˆé™¤é‡å¤ä»£ç )
  - [å¢é‡æ€§](#å¢é‡æ€§)
  - [fixture ä¸è®¾ç½®](#fixture-ä¸è®¾ç½®)
  - [æ€ç´¢ä¸æµ‹è¯•é©±åŠ¨å¼€å‘](#æ€ç´¢ä¸æµ‹è¯•é©±åŠ¨å¼€å‘)

## å‰è¨€

å†™ä¸ªæµ‹è¯•ï¼Œä¿è¯å®ƒé€šè¿‡ï¼Œæ¥ç€é‡æ„è®¾è®¡ï¼Œè¿™å°±æ˜¯ TDD çš„å…¨éƒ¨å†…å®¹äº†ã€‚

## Soundex ç±»

ä»¥ TDD çš„æ–¹å¼å¼€å‘ Soundex ç±»ï¼Œè¿™ç§ç±»å¯ä»¥æå‡åº”ç”¨ç¨‹åºçš„æœç´¢èƒ½åŠ›ã€‚è¿™ä¸ªç®—æ³•æ˜¯å°†å•è¯ç¼–ç ä¸ºä¸€ä¸ªå­—æ¯å’Œä¸‰ä¸ªæ•°å­—ï¼Œå®ƒå°†å‘éŸ³ç›¸ä¼¼çš„å•è¯æ˜ å°„åˆ°ç›¸åŒçš„ç¼–ç ã€‚[Wiki è§£é‡Š](http://en.wikipedia.org/wiki/Soundex)ï¼š

1. ä¿ç•™ç¬¬ä¸€ä¸ªå­—æ¯ã€‚ä¸¢æ‰æ‰€æœ‰å‡ºç°çš„ aã€eã€iã€oã€ uã€yã€hã€wã€‚
2. ä»¥æ•°å­—æ¥ä»£æ›¿è¾…éŸ³ï¼ˆç¬¬ä¸€ä¸ªå­—æ¯é™¤å¤–ï¼‰ï¼š
   - bã€fã€pã€v : 1
   - cã€gã€jã€kã€qã€sã€xã€z : 2
   - dã€t : 3
   - l : 4
   - mã€n : 5
   - r : 6

3. å¦‚æœç›¸é‚»å­—æ¯ç¼–ç ç›¸åŒï¼Œç”¨ä¸€ä¸ªæ•°å­—è¡¨ç¤ºå®ƒä»¬å³å¯ã€‚åŒæ ·ï¼Œå¦‚æœå‡ºç°ä¸¤ä¸ªç¼–ç ç›¸åŒçš„å­—æ¯ï¼Œä¸”å®ƒä»¬è¢«hæˆ–wéš”å¼€ï¼Œä¹Ÿè¿™æ ·å¤„ç†ï¼›ä½†å¦‚æœè¢«å…ƒéŸ³éš”å¼€ï¼Œå°±è¦ç¼–ç ä¸¤æ¬¡ã€‚è¿™æ¡è§„åˆ™åŒæ ·é€‚ç”¨äºç¬¬ä¸€ä¸ªå­—æ¯ã€‚
4. å½“å¾—åˆ°ä¸€ä¸ªå­—æ¯å’Œä¸‰ä¸ªæ•°å­—æ—¶ï¼Œåœæ­¢å¤„ç†ã€‚å¦‚æœéœ€è¦ï¼Œè¡¥é›¶ä»¥å¯¹é½ã€‚

## Let's start

TDD å¹¶éä¸€æ¬¡å°†æ‰€æœ‰æµ‹è¯•å…¨éƒ¨å®ç°ï¼Œè€Œæ˜¯æ¯æ¬¡åªå…³æ³¨ä¸€ä¸ªåŠŸèƒ½ç‚¹å¯¹åº”çš„å•å…ƒæµ‹è¯•ï¼Œå½“å®Œæˆåå†è€ƒè™‘ä¸‹ä¸€ä¸ªéœ€è¦åŠ å…¥ç³»ç»Ÿçš„åŠŸèƒ½ã€‚

**ä»å®è§‚çš„è§’åº¦æ¥çœ‹ï¼ŒTDD çš„è·µè¡Œæ­¥éª¤æ˜¯ï¼šç¼–å†™ä¸€ä¸ªæœ€åŸºæœ¬å•å…ƒåŠŸèƒ½çš„æµ‹è¯•ä»£ç  --> æµ‹è¯•å¤±è´¥ --> å®ç°åŠŸèƒ½ä»£ç æœ€ä½é™åº¦çš„ä½¿å¾—æµ‹è¯•ä»£ç é€šè¿‡æµ‹è¯• --> æµ‹è¯•æˆåŠŸ --> è€ƒè™‘ä¸‹ä¸€ä¸ªåŸºæœ¬å•å…ƒåŠŸèƒ½å¹¶ç¼–å†™å¯¹åº”æµ‹è¯• --> ...ã€‚**

åŸºäºè¿™ä¸€æ€è·¯ï¼Œä»¥ Soundex ä¸¾ä¾‹ï¼šæœ€å…ˆéœ€è¦å®ç°çš„ä¾¿æ˜¯æ­¥éª¤ä¸€ï¼Œä¿ç•™ç¬¬ä¸€ä¸ªå­—æ¯ï¼š

```cpp
#include "catch2/catch.hpp"

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var") { Soundex soundex; }
}
```

- æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª Soundex ä¸€ä¸ªå¯¹è±¡ï¼Œç„¶ååˆ°æ­¤ä¸ºæ­¢ï¼Œå› ä¸ºç°åœ¨å·²ç»ç¼–è¯‘ä¸é€šè¿‡äº†ï¼Œéœ€è¦å…ˆè§£å†³è¿™ä¸ªé—®é¢˜ï¼š
  - åªåœ¨ä¸ºäº†ä½¿å¤±è´¥æµ‹è¯•é€šè¿‡æ—¶æ‰ç¼–å†™äº§å“ä»£ç ã€‚
  - å½“æµ‹è¯•åˆšå¥½å¤±è´¥æ—¶ï¼Œåœæ­¢ç»§ç»­ç¼–å†™ã€‚ç¼–è¯‘å¤±è´¥ä¹Ÿæ˜¯å¤±è´¥ã€‚
  - åªç¼–å†™åˆšå¥½èƒ½è®©ä¸€ä¸ªå¤±è´¥æµ‹è¯•é€šè¿‡çš„äº§å“ä»£ç ã€‚

ç°åœ¨ç¼–è¯‘åœ¨å·²ç»é€šçŸ¥æœªå®šä¹‰ Soundex çš„é”™è¯¯ï¼š

```cpp
#include "catch2/catch.hpp"

// TODO : å½“å‰æš‚æ—¶ä¸æµ‹è¯•ä»£ç åŒä¸€ä¸ªæ–‡ä»¶ï¼Œå½“æ„Ÿè§‰ä»£ç æ”¾åœ¨åŒä¸€ä¸ªæ–‡ä»¶æœ‰äº›éº»çƒ¦æ—¶ï¼Œå†ç”¨åˆé€‚çš„æ–¹å¼è¿å‡º
/**
 * @brief å®ç° Soundex ç±»
 *
 */
class Soundex
{
};

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var") { Soundex soundex; }
}
```

ç°åœ¨ç»§ç»­å‘å‰æ·»åŠ åŠŸèƒ½ï¼Œè®¾è®¡ä½¿ Soundex å¯¹å¤–æä¾›ä¸€ä¸ª encode(string) å…¬å…±æˆå‘˜å‡½æ•°ï¼Œç°åœ¨ä»£ç ä½¿æ— æ³•ç¼–è¯‘é€šè¿‡ï¼š
  
```cpp
...
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char") { auto encoded = soundex.encode("A"); }
    }
}
...
```

ä¿®å¤é”™è¯¯ï¼Œä½¿ Soundex æ”¯æŒ encode æ–¹æ³•ï¼š

```cpp
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     * 
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& word) const { return ""; }
};
```

ç°åœ¨æ£€éªŒè¿”å›å€¼æ˜¯å¦ç¬¦åˆ Soundex ç®—æ³•è½¬æ¢åçš„ç»“æœï¼š

```cpp
...
       WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Catch::Equals("A")); }
        }
...
```

ç°åœ¨å¾—åˆ°äº†ä¸å‰è¾¹ç¼–è¯‘å¤±è´¥ä¸åŒçš„ç»“æœï¼Œæ–­è¨€å¤±è´¥ã€‚å½“ç„¶è¿™æ˜¯å¿…ç„¶çš„ï¼Œå› ä¸º encode æ–¹æ³•å¹¶æ²¡æœ‰ä»€ä¹ˆå®ç°ã€‚

```c++
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return "A"; }
};
```

ç°åœ¨æ–­è¨€èƒ½é€šè¿‡äº†ï¼Œä¸è¿‡åŠŸèƒ½å¹¶æ²¡æœ‰å®Œå–„ï¼Œä¸è¿‡è¿™é‡Œå±•ç¤ºäº†ä¸€ä¸ªæ¸è¿›å¼ TDD å¼€å‘çš„è¿‡ç¨‹ã€‚

## å»æ‰ä¸å¹²å‡€çš„ä»£ç 

å³ä½¿ä»£ç å¾ˆçŸ­ä¹Ÿå¯èƒ½å­˜åœ¨é—®é¢˜ï¼ŒTDD ä¸ºå¼€å‘æä¾›äº†æ›´å¥½çš„æ—¶æœºå»ä¿®å¤ï¼Œå³æ¯æ¬¡å®Œæˆå•å…ƒæµ‹è¯•ä»£ç ä»¥åŠåŠŸèƒ½ä»£ç ç¼–å†™åéƒ½å¯ä»¥è¿›è¡Œå¿«é€Ÿçš„å¢é‡å®¡é˜…ï¼Œé¿å…å°é—®é¢˜è¶Šç§¯è¶Šå¤šã€‚

### å‘½åç©ºé—´çš„ä¿®å¤

å•å…ƒæµ‹è¯•ä»£ç ä¸­ï¼ŒEquals ä½¿ç”¨ Catch å‘½åç©ºé—´æ¯”è¾ƒå½±å“é˜…è¯»è¿è´¯æ€§ï¼Œä½¿ç”¨å‘½åç©ºé—´å°†æ–­è¨€è¯»èµ·æ¥åƒä¸€ä¸ªå¥å­ï¼š

```cpp
#include "catch2/catch.hpp"

using namespace Catch;

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A")); }
        }
    }
}
```

### æ¶ˆé™¤é‡å¤ä»£ç 

é‡å¤ä»£ç å¯¹äºç»´æŠ¤æˆæœ¬å’Œé£é™©éƒ½ä¼šæå‡ã€‚å®¡é˜…ä»£ç æ˜¯éœ€è¦ç€é‡ä¼˜åŒ–ã€‚

åœ¨æ­¤ä¾‹ä¸­æ²¡æœ‰å¤ªæ˜æ˜¾çš„é‡å¤ï¼Œä½†æ˜¯ `"A"` è¿™ä¸ªç¡¬ç¼–ç çš„å­—ç¬¦ä¸²å‡ºç°äº†å¾ˆå¤šå›ï¼Œå¯ä»¥å°† encode æ–¹æ³•ä¸­è¿”å›çš„ç¡¬ç¼–ç  "A" ä¼˜åŒ–æ‰ï¼š

```cpp
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return Word; }
};
```

ä»»ä½•æ—¶å€™ï¼Œä¸€ä¸ªå®Œæ•´çš„æµ‹è¯•é›†åˆå£°æ˜äº†ç³»ç»Ÿä¸­æœŸæœ›çš„è¡Œä¸ºã€‚è¿™é‡Œè•´å«ç€ä¸€ä¸ªæ½œå°è¯ï¼šå¦‚æœä¸€ä¸ªè¡Œä¸ºæ²¡æœ‰å¯¹åº”çš„æµ‹è¯•æ¥æè¿°ï¼Œé‚£è¿™ä¸ªè¡Œä¸ºè¦ä¹ˆä¸å­˜åœ¨ï¼Œè¦ä¹ˆä¸æ˜¯æœŸæœ›çš„ï¼ˆæˆ–è€…æµ‹è¯•æœ¬èº«æ²¡æœ‰å°½åˆ°æè¿°è¡Œä¸ºçš„èŒè´£ï¼‰ã€‚

å½“å†ç» TDD çš„å„ä¸ªå‘¨æœŸæ—¶ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨é‡æ„æ¥å®¡é˜…è®¾è®¡ï¼ŒåŒæ—¶ä¿®å¤å‡ºç°çš„æ‰€æœ‰é—®é¢˜ã€‚é‡æ„çš„ä¸»è¦å…³æ³¨ç‚¹æ˜¯æå‡è¡¨è¾¾èƒ½åŠ›ï¼Œå»é™¤é‡å¤ä»£ç ã€‚å°±ä»£ç çš„å¯ç»´æŠ¤æ€§æ¥è¯´ï¼Œè¿™ä¸¤ä¸ªç‚¹æœ€æœ‰è£¨ç›Šã€‚

## å¢é‡æ€§

å¯¹äºå‰æ–‡çš„ç¡¬ç¼–ç å¯èƒ½å¿ƒå­˜ç–‘è™‘ï¼Œä½†æ˜¯æˆ‘ä»¬éƒ½å¾ˆæ¸…æ¥šç¡¬ç¼–ç æœ€å¤šå­˜åœ¨ä¸€å°ä¼šï¼Œéšç€å¯¹ç›®æ ‡æè¿°è€Œç¼–å†™æ›´å¤šçš„æµ‹è¯•ç”¨ä¾‹ï¼Œé€æ¸å°±ä¼šæ›¿æ¢æ‰ç¡¬ç¼–ç ã€‚

ç»§ç»­å®Œå–„ Soundex åŠŸèƒ½ï¼Œå¯¹äºç°åœ¨çš„ä»£ç å¹¶ä¸ç¬¦ Soundex è§„èŒƒï¼Œä»¥åªä¼ é€’å•ä¸ªå­—ç¬¦ä¸ºå‰æï¼Œå¹¶ä¸ç¬¦åˆç¬¬å››æ¡å³å¦‚æœæ²¡æœ‰ä¸‰ä¸ªæ•°å­—ï¼Œéœ€è¦è¡¥é›¶ã€‚æ¥ä¸‹æ¥ä¸ºè¿™ä¸ªåŠŸèƒ½ç¼–å†™æ–°çš„æµ‹è¯•ã€‚

```cpp
TEST_CASE("Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

å¤±è´¥äº†ï¼š

```shell
/home/caolei/WorkSpace/TDD_Learning/test/Catch2/TestSoundex.cpp:45: FAILED:
  REQUIRE_THAT( encoded, Equals("I000") )
with expansion:
  "I" equals: "I000"

===============================================================================
test cases: 2 | 1 passed | 1 failed
assertions: 2 | 1 passed | 1 failed

```

è®©æµ‹è¯•é€šè¿‡ï¼š

```cpp
/**
 * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
 *
 * @param word
 * @return std::string
 */
std::string encode(const std::string& Word) const { return Word + "000"; }
```

è¿™æ—¶ä¼šå‘ç°ç¬¬ä¸€æ¡ç”¨ä¾‹å¤±è´¥äº†ï¼Œè¿™æ—¶å› ä¸ºç¬¬ä¸€æ¡ç”¨ä¾‹ä¸ Soundex çš„è§„åˆ™ä¸ç¬¦åˆï¼Œä¿®æ”¹å…¶æ–­è¨€è¯­å¥å·²é€‚é…è§„åˆ™ï¼š

```cpp
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
    }
}
```

ç°åœ¨æœ‰ä¸¤æ¡ç›¸ä¼¼çš„æµ‹è¯•ä»…ä»…æ•°æ®æœ‰äº›å·®å¼‚ï¼Œä½†æ˜¯æ²¡æœ‰å…³ç³»ï¼Œæ¯ä¸ªæµ‹è¯•æè¿°ä¸€ç§è¡Œä¸ºã€‚**æˆ‘ä»¬ä¸ä»…è¦ç¡®ä¿ç³»ç»ŸæŒ‰é¢„æœŸå·¥ä½œï¼Œè¿˜è¦è®©æ¯ä¸ªäººçŸ¥é“æ‰€æœ‰æ—¢å®šçš„ç³»ç»Ÿè¡Œä¸ºã€‚**

å®Œæ•´è¿™ä¸ªåŠŸèƒ½å‘¨æœŸåï¼Œè€ƒè™‘é‡æ„ä»£ç ã€‚å¯ä»¥å‘ç° encode çš„å®ç°æœ‰äº›è®©äººè¿·æƒ‘ï¼Œå°¤å…¶æ˜¯ä¸æ¸…æ¥šæ¡æ¬¾çš„äººçœ‹åˆ°è¿™ç§é­”æ•°ç»„åˆå«äººå¿ƒç”ŸåŒæ¶ ğŸ˜¢ï¼Œå› æ­¤éœ€è¦å¯¹å…¶å°è£…ä¸‹ï¼Œæå–ç‹¬ç«‹çš„æ–¹æ³•é…ä»¥æ„å›¾æ˜ç¡®çš„åå­—ã€‚åŒæ—¶è·‘ä¸€ä¸‹æµ‹è¯•ç”¨ä¾‹ç¡®ä¿é‡æ„çš„ä¿®æ”¹å¯¹äºå·²æœ‰åŠŸèƒ½æ— å½±å“ã€‚

```cpp
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(Word); }

private:
    /**
     * @brief æŒ‰ç…§ Soundex çš„è§„åˆ™è¦æ±‚è¿›è¡Œè¡¥é›¶
     *
     * @param Word
     * @return std::string
     */
    std::string zeroPad(const std::string& Word) const { return Word + "000"; }
};
```

## fixture ä¸è®¾ç½®

åœ¨é‡æ„çš„æ—¶å€™ï¼Œä¸ä»…è¦å®¡é˜…äº§å“ä»£ç ï¼Œè¿˜è¦å®¡é˜…æµ‹è¯•ã€‚ç°åœ¨æµ‹è¯•ä»£ç ä¸­å­˜åœ¨ä¸€äº›é‡å¤çš„åœ°æ–¹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„ GIVEN éƒ½éœ€è¦åˆ›å»ºä¸€ä¸ª Soundex å¯¹è±¡ã€‚æœ‰ä¸¤ç§æ–¹å¼ä¿®æ”¹ï¼š

- å°†ä¸¤ä¸ªæµ‹è¯•ç”¨ä¾‹åˆå¹¶å…¥ä¸€ä¸ªï¼Œå…¬ç”¨ä¸€ä¸ª GIVENã€‚ä¼˜ç‚¹æ˜¯æ¯”è¾ƒæ–¹ä¾¿ä¿®æ”¹ï¼Œç¼ºç‚¹å¦‚æœç”¨ä¾‹æ¯”è¾ƒå¤šï¼Œæµ‹è¯•ä»£ç ä¼šå¾ˆé•¿ã€‚

```cpp
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
        // ç¬¬äºŒä¸ª WHEN æ‰§è¡Œæ—¶ä¼šé‡æ–°ä» GIVEN è¿è¡Œï¼Œä¸å—å‰ä¸€ä¸ª WHEN å½±å“
        WHEN("Input one another char")
        {
            auto encoded = soundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

- ç¬¬äºŒç§ä¾¿æ˜¯ä½¿ç”¨ class fixture æ–¹æ³•ï¼Œæˆ–è®¸ GIVEN ä¸ WHEN ä¾æ—§å­˜åœ¨é‡å¤ï¼Œä½†æ˜¯ä¸ªäººè®¤ä¸ºä½œä¸ºå•å…ƒæµ‹è¯•æ¯ä¸€ä¸ªæµ‹è¯•é˜…è¯»èµ·æ¥é€šé¡ºä¹Ÿæ˜¯å¾ˆé‡è¦çš„ï¼Œå¹¶ä¸”æœ¬æ–‡é‡‡ç”¨çš„å•å…ƒæµ‹è¯•ç¼–å†™é£æ ¼å°±æ˜¯ BDD-ScenarioGivenWhenThenï¼š

```cpp
class FixtureSoundex
{
public:
    Soundex MSoundex;
};

TEST_CASE_METHOD(FixtureSoundex, "Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Input one char")
        {
            auto encoded = MSoundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
    }
}

TEST_CASE_METHOD(FixtureSoundex, "Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Input one char")
        {
            auto encoded = MSoundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

Catch2 ä¼šåœ¨è¿è¡Œæ¯ä¸ªæµ‹è¯•æ—¶åˆ›å»º fixture å®ä¾‹ã€‚ç°åœ¨å°±å¯ä»¥åˆ é™¤æµ‹è¯•å†…çš„å±€éƒ¨å˜é‡ soundexã€‚ç°åœ¨ Soundex ä»£ç æœ‰äº›é•¿äº†ï¼Œæ˜¯æ—¶å€™è¦æŠŠ TODO äº‹é¡¹è§£å†³ä¸€ä¸‹ã€‚

```cpp
//Include/Soundex.h
#pragma once

#include <string>

// TODO: æš‚æ—¶å°†å®ç°ä¹Ÿéƒ½æ”¾å…¥åŒä¸€ä¸ªæ–‡ä»¶ä¸­æ¯”è¾ƒæ–¹ä¾¿ä¿®æ”¹ï¼Œåç»­åˆé€‚çš„æ—¶æœºæŠ½å‡º
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(Word); }

private:
    /**
     * @brief å®‰è£… Soundex æ¡æ¬¾4 è¦æ±‚è¿›è¡Œè¡¥é›¶
     *
     * @param Word
     * @return std::string
     */
    std::string zeroPad(const std::string& Word) const { return Word + "000"; }
};

```

æµ‹è¯•ä»£ç ï¼š

```cpp
//test/Catch2/TestSoundex.cpp
#include "Soundex.h"
#include "catch2/catch.hpp"
#include "spdlog/spdlog.h"
using namespace Catch;

class FixtureSoundex
{
public:
    Soundex MSoundex;
};

TEST_CASE_METHOD(FixtureSoundex, "Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Input one char")
        {
            auto encoded = MSoundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
    }
}

TEST_CASE_METHOD(FixtureSoundex, "Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Input one char")
        {
            auto encoded = MSoundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

## æ€ç´¢ä¸æµ‹è¯•é©±åŠ¨å¼€å‘

ç®€å•åœ°è¯´ï¼ŒTDDçš„å‘¨æœŸå°±æ˜¯å†™ä¸€ä¸ªæµ‹è¯•ï¼Œå…ˆç¡®ä¿æµ‹è¯•å¤±è´¥ï¼Œç„¶åç¼–ç è®©æµ‹è¯•é€šè¿‡ï¼Œæ¥ç€å®¡é˜…ä»£ç å’Œæ‰“ç£¨è®¾è®¡ï¼ˆåŒ…æ‹¬æµ‹è¯•çš„è®¾è®¡ï¼‰ï¼Œæœ€åç¡®ä¿æ‰€æœ‰æµ‹è¯•ä¾ç„¶é€šè¿‡ã€‚

æ¥ä¸‹æ¥å°†è¦å¤„ç†è§„åˆ™2ï¼šå³åœ¨ç¬¬ä¸€ä¸ªå­—æ¯åï¼Œç”¨æ•°å­—æ›¿æ¢è¾…éŸ³ã€‚æ›¿æ¢è§„åˆ™è¡¨ä¸­å­—æ¯ b å¯¹åº”æ•°å­— 1ï¼Œä»¥æ­¤ç¼–å†™ç”¨ä¾‹ï¼š

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Retains sole letter of one letter word")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Enter a word")
        {
            auto encoded = MSoundex.encode("Ab");
            THEN("Check that the return value Retains sole letter of one letter word") { REQUIRE_THAT(encoded, Equals("A100")); }
        }
    }
}
```

ä¸å‡ºæ‰€æ–™çš„å¤±è´¥ï¼Œæ¥ä¸‹æ¥ä¾¿æ˜¯è®©æµ‹è¯•é€šè¿‡ï¼Œç„¶åé‡æ„åŠŸèƒ½ä»£ç ã€‚åœ¨å¯»æ±‚è§£å†³æ–¹æ¡ˆæ—¶ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦æ‰¾åˆ°ä¸€ä¸ªé€šç”¨çš„æ–¹æ³•ï¼Œ**ä½†æ˜¯ä¹Ÿä¸è¦ä½¿ç”¨å·²æœ‰çš„å¤„ç†é€»è¾‘**ï¼Œä¾‹å¦‚ï¼š

```cpp
std::string encode(const std::string& word) const {
    if (word == "Ab") return "A100";
    return zeroPad(word);
}
```

ç¼–å†™äº†è¿™ä¸ªç‰¹ä¾‹ï¼Œä½†æ˜¯çœ‹èµ·æ¥å®ƒå°±åƒå¯¹ Ab è¿›è¡Œç‰¹æ®Šå¤„ç†æˆ A1 åçš„è¡¥é›¶è¾“å‡ºï¼Œä½†æ˜¯æˆ‘ä»¬å·²æœ‰ zeroPad äº†ï¼Œè™½è¯´ç‰¹ä¾‹å¹¶éé”™è¯¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨å…¶ä»–çš„æµ‹è¯•ç”¨ä¾‹æ¥ä¿®æ”¹è¿™ä¸ªç‰¹ä¾‹ï¼Œè¿™é‡Œä»…ä»…æ˜¯åˆ—ä¸¾å‡ºå½“æˆ‘æƒ³è¦åŠŸèƒ½å‘å‰å¼€å‘æ—¶çš„æ ‡å‡†ï¼Œå› ä¸ºä¸€ç›´æ·»åŠ ç‰¹ä¾‹ä¹Ÿæ˜¯å¯è¡Œçš„ä¸æ˜¯ä¹ˆğŸ˜€ã€‚

```cpp
/**
 * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
 *
 * @param word
 * @return std::string
 */
std::string encode(const std::string& Word) const
{
    auto encoded = Word.substr(0, 1);

    if (Word.length() > 1) { encoded += "1"; }
    return zeroPad(encoded);
}
```

Opsï¼Œè¡¥é›¶å‡ºç°äº†é”™è¯¯ï¼š

```shell
/home/caolei/WorkSpace/TDD_Learning/test/Catch2/TestSoundex.cpp:43: FAILED:
  REQUIRE_THAT( encoded, Equals("A100") )
with expansion:
  "A1000" equals: "A100"

===============================================================================
test cases: 3 | 2 passed | 1 failed
assertions: 3 | 2 passed | 1 failed
```

ä¿®æ”¹ zeroPad æ–¹æ³•ä»¥é€šè¿‡æµ‹è¯•ï¼š

```cpp
/**
 * @brief å®‰è£… Soundex æ¡æ¬¾4 è¦æ±‚è¿›è¡Œè¡¥é›¶
 *
 * @param Word
 * @return std::string
 */
std::string zeroPad(const std::string& Word) const
{
    auto zerosNeeded = 4 - Word.length();
    return Word + std::string(zerosNeeded, '0');
}
```

ç°åœ¨çœ‹èµ·æ¥ä¸é”™ï¼Œç”¨ä¾‹ä¹Ÿå·²ç»é€šè¿‡äº†ã€‚ä½†æ˜¯å¯¹äº encode æ–¹æ³•çš„å®ç°è¿˜æ˜¯æœ‰äº›ä¸æ»¡æ„ï¼Œå…¶ä¸­å……æ–¥äº†ä¸€äº›ç¼–ç ç»†èŠ‚å’Œé­”æ•°ï¼Œå¯¹äºä¸ç†Ÿæ‚‰åŠŸèƒ½çš„å…¶ä»–äººé˜…è¯»èµ·æ¥æ˜¯ç¾éš¾çš„ï¼Œä¸å¤šåºŸè¯é‡æ„å®ƒğŸš€ï¼š

```cpp
#pragma once

#include <string>

// TODO: æš‚æ—¶å°†å®ç°ä¹Ÿéƒ½æ”¾å…¥åŒä¸€ä¸ªæ–‡ä»¶ä¸­æ¯”è¾ƒæ–¹ä¾¿ä¿®æ”¹ï¼Œåç»­åˆé€‚çš„å®é™…æŠ½å‡º
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(head(Word) + encodedDigits(Word)); }

private:
    /**
     * @brief è·å–å•è¯çš„ç¬¬ä¸€ä¸ªå­—æ¯
     *
     * @param Word
     * @return std::string
     */
    std::string head(const std::string& Word) const { return Word.substr(0, 1); }

    /**
     * @brief è·å–é¦–å­—æ¯åå…¶ä»–å­—ç¬¦è½¬åŒ–çš„å¯¹åº”æ•°å­—
     *
     * @param Word
     * @return std::string
     */
    std::string encodedDigits(const std::string& Word) const
    {
        if (Word.length() > 1) return "1";
        return "";
    }
    /**
     * @brief æŒ‰ç…§ Soundex çš„è§„åˆ™è¦æ±‚è¿›è¡Œè¡¥é›¶
     *
     * @param Word
     * @return std::string
     */
    std::string zeroPad(const std::string& Word) const
    {
        auto zerosNeeded = 4 - Word.length();
        return Word + std::string(zerosNeeded, '0');
    }
};
```

ä»¥å£°æ˜æ€§çš„æ–¹å¼ç»„ç»‡ä»£ç ï¼Œä½¿å…¶éå¸¸æ˜“äºç†è§£ã€‚è®¾è®¡ä¸­éå¸¸é‡è¦çš„ä¸€æ–¹é¢æ˜¯ä»å®ç°ï¼ˆæ€ä¹ˆåšï¼‰ä¸­åˆ†ç¦»æ¥å£ï¼ˆåšä»€ä¹ˆï¼‰ï¼Œè¿™æä¾›äº†è¿ˆå‘æ›´é«˜å±‚æ¬¡è®¾è®¡æ–¹æ¡ˆçš„è·³æ¿ã€‚

>æœ‰æ—¶ä¹Ÿä¼šæ‹…å¿ƒä¸€äº›å®ç°çš„ç»†èŠ‚å¹¶ä¸æ˜¯é‚£ä¹ˆå¥½ï¼šã€‚ç¬¬ä¸€ï¼Œæ˜¯ä¸æ˜¯åº”è¯¥ç”¨ stringstreamï¼Œè€Œä¸æ˜¯ç›´æ¥å°†å­—ç¬¦ä¸²è¿æ¥èµ·æ¥ï¼Ÿç¬¬äºŒï¼Œä¸ºä»€ä¹ˆä¸å°½å¯èƒ½åœ°ç”¨å•ç‹¬çš„ charï¼Ÿä¾‹å¦‚ï¼Œä¸ºä»€ä¹ˆç”¨ return words.substr(0, 1); è€Œé return word.front();ï¼Ÿç¬¬ä¸‰ï¼Œç”¨ return std::string(); ä¸æ˜¯æ¯” return ""; æ›´å¥½å—ï¼Ÿ
>
> è¿™äº›æ›¿ä»£çš„ä»£ç æ–¹æ¡ˆå¯èƒ½æ›´å¥½ã€‚ä½†è¿™äº›éƒ½æ˜¯è¿‡æ—©ä¼˜åŒ–ï¼ˆpremature optimizationï¼‰ã€‚è¿™ä¸ªæ—¶å€™ï¼Œä¸€ä¸ªå¥½çš„è®¾è®¡ï¼ˆæ¥å£ä¸€è‡´ä¸”ä»£ç å¯è¯»æ€§é«˜ï¼‰æ›´é‡è¦ã€‚ä¸€æ—¦ä»¥ç‰¢é çš„è®¾è®¡å®ç°äº†æ­£ç¡®çš„è¡Œä¸ºåï¼Œå†è€ƒè™‘æ˜¯å¦ä¼˜åŒ–æ€§èƒ½ã€‚

å…ˆä¸è¦è€ƒè™‘å¯¹äºæ€§èƒ½è¿›è¡Œä¼˜åŒ–ï¼Œè¿˜æ˜¯è¦ä¼˜å…ˆè€ƒè™‘å¥½çš„ä»£ç è®¾è®¡ï¼Œä¾‹å¦‚æ¶ˆé™¤ä»£ç ä¸­çš„`é­”æ•°`ï¼Œå–è€Œä»£ä¹‹ä¸€ä¸ªåˆç†åå­—çš„å¸¸é‡ã€‚

```cpp
static const size_t MaxCodeLength{4};
......
/**
 * @brief å®‰è£… Soundex çš„è§„åˆ™è¦æ±‚è¿›è¡Œè¡¥é›¶
 *
 * @param Word
 * @return std::string
 */
std::string zeroPad(const std::string& Word) const
{
    auto zerosNeeded = MaxCodeLength - Word.length();
    return Word + std::string(zerosNeeded, '0');
}
```

å¯¹äº encodedDigits() ä¸­çš„ç¡¬ç¼–ç  `1`ï¼Œéœ€è¦ä»£ç å°†å­—æ¯ b æ›¿æ¢æˆ 1ï¼Œè€Œå†™åç»­è¿˜è¦æ”¯æŒå¯¹å…¶ä»–å­—ç¬¦çš„æ•°å­—è½¬æ¢ï¼Œå¯ä»¥é€šè¿‡ä¸€ä¸ªåˆç†çš„å‡½æ•°åå­—æ›¿ä»£ï¼Œæœ€ç»ˆçš„ä»£ç å¦‚ä¸‹ï¼š

```cpp
/**
 * @brief è·å–é¦–å­—æ¯åå…¶ä»–å­—ç¬¦è½¬åŒ–çš„å¯¹åº”æ•°å­—
 *
 * @param Word
 * @return std::string
 */
std::string encodedDigits(const std::string& Word) const
{
    if (Word.length() > 1) return encodedDigit();
    return "";
}

/**
 * @brief è·å–ä¸€ä¸ªå­—ç¬¦å¯¹åº”çš„æ•°å­—
 *
 * @return std::string
 */
std::string encodedDigit() const { return "1"; }
```
