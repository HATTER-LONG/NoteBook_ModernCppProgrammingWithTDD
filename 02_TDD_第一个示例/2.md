# æµ‹è¯•é©±åŠ¨å¼€å‘ï¼šç¬¬ä¸€ä¸ªç¤ºä¾‹

- [æµ‹è¯•é©±åŠ¨å¼€å‘ï¼šç¬¬ä¸€ä¸ªç¤ºä¾‹](#æµ‹è¯•é©±åŠ¨å¼€å‘ç¬¬ä¸€ä¸ªç¤ºä¾‹)
  - [å‰è¨€](#å‰è¨€)
  - [Soundex ç±»](#soundex-ç±»)
  - [Let's start](#lets-start)
  - [å»æ‰ä¸å¹²å‡€çš„ä»£ç ](#å»æ‰ä¸å¹²å‡€çš„ä»£ç )
    - [å‘½åç©ºé—´çš„ä¿®å¤](#å‘½åç©ºé—´çš„ä¿®å¤)
    - [æ¶ˆé™¤é‡å¤ä»£ç ](#æ¶ˆé™¤é‡å¤ä»£ç )
  - [å¢é‡æ€§](#å¢é‡æ€§)
  - [fixture ä¸è®¾ç½®](#fixture-ä¸è®¾ç½®)
  - [æ€ç´¢ä¸æµ‹è¯•é©±åŠ¨å¼€å‘](#æ€ç´¢ä¸æµ‹è¯•é©±åŠ¨å¼€å‘)
  - [æµ‹è¯•é©±åŠ¨](#æµ‹è¯•é©±åŠ¨)
  - [å¦‚æœå‡ºç°åˆ«çš„æƒ…å†µå‘¢](#å¦‚æœå‡ºç°åˆ«çš„æƒ…å†µå‘¢)
  - [ä¸€æ¬¡åªåšä¸€ä»¶äº‹](#ä¸€æ¬¡åªåšä¸€ä»¶äº‹)
  - [é™åˆ¶é•¿åº¦](#é™åˆ¶é•¿åº¦)
  - [ä¸¢æ‰å…ƒéŸ³](#ä¸¢æ‰å…ƒéŸ³)

## å‰è¨€

å†™ä¸ªæµ‹è¯•ï¼Œä¿è¯å®ƒé€šè¿‡ï¼Œæ¥ç€é‡æ„è®¾è®¡ï¼Œè¿™å°±æ˜¯ TDD çš„å…¨éƒ¨å†…å®¹äº†ã€‚

## Soundex ç±»

ä»¥ TDD çš„æ–¹å¼å¼€å‘ Soundex ç±»ï¼Œè¿™ç§ç±»å¯ä»¥æå‡åº”ç”¨ç¨‹åºçš„æœç´¢èƒ½åŠ›ã€‚è¿™ä¸ªç®—æ³•æ˜¯å°†å•è¯ç¼–ç ä¸ºä¸€ä¸ªå­—æ¯å’Œä¸‰ä¸ªæ•°å­—ï¼Œå®ƒå°†å‘éŸ³ç›¸ä¼¼çš„å•è¯æ˜ å°„åˆ°ç›¸åŒçš„ç¼–ç ã€‚[Wiki è§£é‡Š](http://en.wikipedia.org/wiki/Soundex)ï¼š

1. ä¿ç•™ç¬¬ä¸€ä¸ªå­—æ¯ã€‚ä¸¢æ‰æ‰€æœ‰å‡ºç°çš„ aã€eã€iã€oã€ uã€yã€hã€wã€‚
2. ä»¥æ•°å­—æ¥ä»£æ›¿è¾…éŸ³ï¼ˆç¬¬ä¸€ä¸ªå­—æ¯é™¤å¤–ï¼‰ï¼š
   - bã€fã€pã€v : 1
   - cã€gã€jã€kã€qã€sã€xã€z : 2
   - dã€t : 3
   - l : 4
   - mã€n : 5
   - r : 6

3. å¦‚æœç›¸é‚»å­—æ¯ç¼–ç ç›¸åŒï¼Œç”¨ä¸€ä¸ªæ•°å­—è¡¨ç¤ºå®ƒä»¬å³å¯ã€‚åŒæ ·ï¼Œå¦‚æœå‡ºç°ä¸¤ä¸ªç¼–ç ç›¸åŒçš„å­—æ¯ï¼Œä¸”å®ƒä»¬è¢«hæˆ–wéš”å¼€ï¼Œä¹Ÿè¿™æ ·å¤„ç†ï¼›ä½†å¦‚æœè¢«å…ƒéŸ³éš”å¼€ï¼Œå°±è¦ç¼–ç ä¸¤æ¬¡ã€‚è¿™æ¡è§„åˆ™åŒæ ·é€‚ç”¨äºç¬¬ä¸€ä¸ªå­—æ¯ã€‚
4. å½“å¾—åˆ°ä¸€ä¸ªå­—æ¯å’Œä¸‰ä¸ªæ•°å­—æ—¶ï¼Œåœæ­¢å¤„ç†ã€‚å¦‚æœéœ€è¦ï¼Œè¡¥é›¶ä»¥å¯¹é½ã€‚

## Let's start

TDD å¹¶éä¸€æ¬¡å°†æ‰€æœ‰æµ‹è¯•å…¨éƒ¨å®ç°ï¼Œè€Œæ˜¯æ¯æ¬¡åªå…³æ³¨ä¸€ä¸ªåŠŸèƒ½ç‚¹å¯¹åº”çš„å•å…ƒæµ‹è¯•ï¼Œå½“å®Œæˆåå†è€ƒè™‘ä¸‹ä¸€ä¸ªéœ€è¦åŠ å…¥ç³»ç»Ÿçš„åŠŸèƒ½ã€‚

**ä»å®è§‚çš„è§’åº¦æ¥çœ‹ï¼ŒTDD çš„è·µè¡Œæ­¥éª¤æ˜¯ï¼šç¼–å†™ä¸€ä¸ªæœ€åŸºæœ¬å•å…ƒåŠŸèƒ½çš„æµ‹è¯•ä»£ç  --> æµ‹è¯•å¤±è´¥ --> å®ç°åŠŸèƒ½ä»£ç æœ€ä½é™åº¦çš„ä½¿å¾—æµ‹è¯•ä»£ç é€šè¿‡æµ‹è¯• --> æµ‹è¯•æˆåŠŸ --> è€ƒè™‘ä¸‹ä¸€ä¸ªåŸºæœ¬å•å…ƒåŠŸèƒ½å¹¶ç¼–å†™å¯¹åº”æµ‹è¯• --> ...ã€‚**

åŸºäºè¿™ä¸€æ€è·¯ï¼Œä»¥ Soundex ä¸¾ä¾‹ï¼šæœ€å…ˆéœ€è¦å®ç°çš„ä¾¿æ˜¯æ­¥éª¤ä¸€ï¼Œä¿ç•™ç¬¬ä¸€ä¸ªå­—æ¯ï¼š

```cpp
#include "catch2/catch.hpp"

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var") { Soundex soundex; }
}
```

- æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª Soundex ä¸€ä¸ªå¯¹è±¡ï¼Œç„¶ååˆ°æ­¤ä¸ºæ­¢ï¼Œå› ä¸ºç°åœ¨å·²ç»ç¼–è¯‘ä¸é€šè¿‡äº†ï¼Œéœ€è¦å…ˆè§£å†³è¿™ä¸ªé—®é¢˜ï¼š
  - åªåœ¨ä¸ºäº†ä½¿å¤±è´¥æµ‹è¯•é€šè¿‡æ—¶æ‰ç¼–å†™äº§å“ä»£ç ã€‚
  - å½“æµ‹è¯•åˆšå¥½å¤±è´¥æ—¶ï¼Œåœæ­¢ç»§ç»­ç¼–å†™ã€‚ç¼–è¯‘å¤±è´¥ä¹Ÿæ˜¯å¤±è´¥ã€‚
  - åªç¼–å†™åˆšå¥½èƒ½è®©ä¸€ä¸ªå¤±è´¥æµ‹è¯•é€šè¿‡çš„äº§å“ä»£ç ã€‚

ç°åœ¨ç¼–è¯‘åœ¨å·²ç»é€šçŸ¥æœªå®šä¹‰ Soundex çš„é”™è¯¯ï¼š

```cpp
#include "catch2/catch.hpp"

// !TODO : å½“å‰æš‚æ—¶ä¸æµ‹è¯•ä»£ç åŒä¸€ä¸ªæ–‡ä»¶ï¼Œå½“æ„Ÿè§‰ä»£ç æ”¾åœ¨åŒä¸€ä¸ªæ–‡ä»¶æœ‰äº›éº»çƒ¦æ—¶ï¼Œå†ç”¨åˆé€‚çš„æ–¹å¼è¿å‡º
/**
 * @brief å®ç° Soundex ç±»
 *
 */
class Soundex
{
};

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var") { Soundex soundex; }
}
```

ç°åœ¨ç»§ç»­å‘å‰æ·»åŠ åŠŸèƒ½ï¼Œè®¾è®¡ä½¿ Soundex å¯¹å¤–æä¾›ä¸€ä¸ª encode(string) å…¬å…±æˆå‘˜å‡½æ•°ï¼Œç°åœ¨ä»£ç ä½¿æ— æ³•ç¼–è¯‘é€šè¿‡ï¼š
  
```cpp
...
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char") { auto encoded = soundex.encode("A"); }
    }
}
...
```

ä¿®å¤é”™è¯¯ï¼Œä½¿ Soundex æ”¯æŒ encode æ–¹æ³•ï¼š

```cpp
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     * 
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& word) const { return ""; }
};
```

ç°åœ¨æ£€éªŒè¿”å›å€¼æ˜¯å¦ç¬¦åˆ Soundex ç®—æ³•è½¬æ¢åçš„ç»“æœï¼š

```cpp
...
       WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Catch::Equals("A")); }
        }
...
```

ç°åœ¨å¾—åˆ°äº†ä¸å‰è¾¹ç¼–è¯‘å¤±è´¥ä¸åŒçš„ç»“æœï¼Œæ–­è¨€å¤±è´¥ã€‚å½“ç„¶è¿™æ˜¯å¿…ç„¶çš„ï¼Œå› ä¸º encode æ–¹æ³•å¹¶æ²¡æœ‰ä»€ä¹ˆå®ç°ã€‚

```c++
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return "A"; }
};
```

ç°åœ¨æ–­è¨€èƒ½é€šè¿‡äº†ï¼Œä¸è¿‡åŠŸèƒ½å¹¶æ²¡æœ‰å®Œå–„ï¼Œä¸è¿‡è¿™é‡Œå±•ç¤ºäº†ä¸€ä¸ªæ¸è¿›å¼ TDD å¼€å‘çš„è¿‡ç¨‹ã€‚

## å»æ‰ä¸å¹²å‡€çš„ä»£ç 

å³ä½¿ä»£ç å¾ˆçŸ­ä¹Ÿå¯èƒ½å­˜åœ¨é—®é¢˜ï¼ŒTDD ä¸ºå¼€å‘æä¾›äº†æ›´å¥½çš„æ—¶æœºå»ä¿®å¤ï¼Œå³æ¯æ¬¡å®Œæˆå•å…ƒæµ‹è¯•ä»£ç ä»¥åŠåŠŸèƒ½ä»£ç ç¼–å†™åéƒ½å¯ä»¥è¿›è¡Œå¿«é€Ÿçš„å¢é‡å®¡é˜…ï¼Œé¿å…å°é—®é¢˜è¶Šç§¯è¶Šå¤šã€‚

### å‘½åç©ºé—´çš„ä¿®å¤

å•å…ƒæµ‹è¯•ä»£ç ä¸­ï¼ŒEquals ä½¿ç”¨ Catch å‘½åç©ºé—´æ¯”è¾ƒå½±å“é˜…è¯»è¿è´¯æ€§ï¼Œä½¿ç”¨å‘½åç©ºé—´å°†æ–­è¨€è¯»èµ·æ¥åƒä¸€ä¸ªå¥å­ï¼š

```cpp
#include "catch2/catch.hpp"

using namespace Catch;

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A")); }
        }
    }
}
```

### æ¶ˆé™¤é‡å¤ä»£ç 

é‡å¤ä»£ç å¯¹äºç»´æŠ¤æˆæœ¬å’Œé£é™©éƒ½ä¼šæå‡ã€‚å®¡é˜…ä»£ç æ˜¯éœ€è¦ç€é‡ä¼˜åŒ–ã€‚

åœ¨æ­¤ä¾‹ä¸­æ²¡æœ‰å¤ªæ˜æ˜¾çš„é‡å¤ï¼Œä½†æ˜¯ `"A"` è¿™ä¸ªç¡¬ç¼–ç çš„å­—ç¬¦ä¸²å‡ºç°äº†å¾ˆå¤šå›ï¼Œå¯ä»¥å°† encode æ–¹æ³•ä¸­è¿”å›çš„ç¡¬ç¼–ç  "A" ä¼˜åŒ–æ‰ï¼š

```cpp
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return Word; }
};
```

ä»»ä½•æ—¶å€™ï¼Œä¸€ä¸ªå®Œæ•´çš„æµ‹è¯•é›†åˆå£°æ˜äº†ç³»ç»Ÿä¸­æœŸæœ›çš„è¡Œä¸ºã€‚è¿™é‡Œè•´å«ç€ä¸€ä¸ªæ½œå°è¯ï¼šå¦‚æœä¸€ä¸ªè¡Œä¸ºæ²¡æœ‰å¯¹åº”çš„æµ‹è¯•æ¥æè¿°ï¼Œé‚£è¿™ä¸ªè¡Œä¸ºè¦ä¹ˆä¸å­˜åœ¨ï¼Œè¦ä¹ˆä¸æ˜¯æœŸæœ›çš„ï¼ˆæˆ–è€…æµ‹è¯•æœ¬èº«æ²¡æœ‰å°½åˆ°æè¿°è¡Œä¸ºçš„èŒè´£ï¼‰ã€‚

å½“å†ç» TDD çš„å„ä¸ªå‘¨æœŸæ—¶ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨é‡æ„æ¥å®¡é˜…è®¾è®¡ï¼ŒåŒæ—¶ä¿®å¤å‡ºç°çš„æ‰€æœ‰é—®é¢˜ã€‚é‡æ„çš„ä¸»è¦å…³æ³¨ç‚¹æ˜¯æå‡è¡¨è¾¾èƒ½åŠ›ï¼Œå»é™¤é‡å¤ä»£ç ã€‚å°±ä»£ç çš„å¯ç»´æŠ¤æ€§æ¥è¯´ï¼Œè¿™ä¸¤ä¸ªç‚¹æœ€æœ‰è£¨ç›Šã€‚

## å¢é‡æ€§

å¯¹äºå‰æ–‡çš„ç¡¬ç¼–ç å¯èƒ½å¿ƒå­˜ç–‘è™‘ï¼Œä½†æ˜¯æˆ‘ä»¬éƒ½å¾ˆæ¸…æ¥šç¡¬ç¼–ç æœ€å¤šå­˜åœ¨ä¸€å°ä¼šï¼Œéšç€å¯¹ç›®æ ‡æè¿°è€Œç¼–å†™æ›´å¤šçš„æµ‹è¯•ç”¨ä¾‹ï¼Œé€æ¸å°±ä¼šæ›¿æ¢æ‰ç¡¬ç¼–ç ã€‚

ç»§ç»­å®Œå–„ Soundex åŠŸèƒ½ï¼Œå¯¹äºç°åœ¨çš„ä»£ç å¹¶ä¸ç¬¦ Soundex è§„èŒƒï¼Œä»¥åªä¼ é€’å•ä¸ªå­—ç¬¦ä¸ºå‰æï¼Œå¹¶ä¸ç¬¦åˆç¬¬å››æ¡å³å¦‚æœæ²¡æœ‰ä¸‰ä¸ªæ•°å­—ï¼Œéœ€è¦è¡¥é›¶ã€‚æ¥ä¸‹æ¥ä¸ºè¿™ä¸ªåŠŸèƒ½ç¼–å†™æ–°çš„æµ‹è¯•ã€‚

```cpp
TEST_CASE("Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

å¤±è´¥äº†ï¼š

```shell
/home/caolei/WorkSpace/TDD_Learning/test/Catch2/TestSoundex.cpp:45: FAILED:
  REQUIRE_THAT( encoded, Equals("I000") )
with expansion:
  "I" equals: "I000"

===============================================================================
test cases: 2 | 1 passed | 1 failed
assertions: 2 | 1 passed | 1 failed

```

è®©æµ‹è¯•é€šè¿‡ï¼š

```cpp
/**
 * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
 *
 * @param word
 * @return std::string
 */
std::string encode(const std::string& Word) const { return Word + "000"; }
```

è¿™æ—¶ä¼šå‘ç°ç¬¬ä¸€æ¡ç”¨ä¾‹å¤±è´¥äº†ï¼Œè¿™æ—¶å› ä¸ºç¬¬ä¸€æ¡ç”¨ä¾‹ä¸ Soundex çš„è§„åˆ™ä¸ç¬¦åˆï¼Œä¿®æ”¹å…¶æ–­è¨€è¯­å¥å·²é€‚é…è§„åˆ™ï¼š

```cpp
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
    }
}
```

ç°åœ¨æœ‰ä¸¤æ¡ç›¸ä¼¼çš„æµ‹è¯•ä»…ä»…æ•°æ®æœ‰äº›å·®å¼‚ï¼Œä½†æ˜¯æ²¡æœ‰å…³ç³»ï¼Œæ¯ä¸ªæµ‹è¯•æè¿°ä¸€ç§è¡Œä¸ºã€‚**æˆ‘ä»¬ä¸ä»…è¦ç¡®ä¿ç³»ç»ŸæŒ‰é¢„æœŸå·¥ä½œï¼Œè¿˜è¦è®©æ¯ä¸ªäººçŸ¥é“æ‰€æœ‰æ—¢å®šçš„ç³»ç»Ÿè¡Œä¸ºã€‚**

å®Œæ•´è¿™ä¸ªåŠŸèƒ½å‘¨æœŸåï¼Œè€ƒè™‘é‡æ„ä»£ç ã€‚å¯ä»¥å‘ç° encode çš„å®ç°æœ‰äº›è®©äººè¿·æƒ‘ï¼Œå°¤å…¶æ˜¯ä¸æ¸…æ¥šæ¡æ¬¾çš„äººçœ‹åˆ°è¿™ç§é­”æ•°ç»„åˆå«äººå¿ƒç”ŸåŒæ¶ ğŸ˜¢ï¼Œå› æ­¤éœ€è¦å¯¹å…¶å°è£…ä¸‹ï¼Œæå–ç‹¬ç«‹çš„æ–¹æ³•é…ä»¥æ„å›¾æ˜ç¡®çš„åå­—ã€‚åŒæ—¶è·‘ä¸€ä¸‹æµ‹è¯•ç”¨ä¾‹ç¡®ä¿é‡æ„çš„ä¿®æ”¹å¯¹äºå·²æœ‰åŠŸèƒ½æ— å½±å“ã€‚

```cpp
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(Word); }

private:
    /**
     * @brief æŒ‰ç…§ Soundex çš„è§„åˆ™è¦æ±‚è¿›è¡Œè¡¥é›¶
     *
     * @param Word
     * @return std::string
     */
    std::string zeroPad(const std::string& Word) const { return Word + "000"; }
};
```

## fixture ä¸è®¾ç½®

åœ¨é‡æ„çš„æ—¶å€™ï¼Œä¸ä»…è¦å®¡é˜…äº§å“ä»£ç ï¼Œè¿˜è¦å®¡é˜…æµ‹è¯•ã€‚ç°åœ¨æµ‹è¯•ä»£ç ä¸­å­˜åœ¨ä¸€äº›é‡å¤çš„åœ°æ–¹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„ GIVEN éƒ½éœ€è¦åˆ›å»ºä¸€ä¸ª Soundex å¯¹è±¡ã€‚æœ‰ä¸¤ç§æ–¹å¼ä¿®æ”¹ï¼š

- å°†ä¸¤ä¸ªæµ‹è¯•ç”¨ä¾‹åˆå¹¶å…¥ä¸€ä¸ªï¼Œå…¬ç”¨ä¸€ä¸ª GIVENã€‚ä¼˜ç‚¹æ˜¯æ¯”è¾ƒæ–¹ä¾¿ä¿®æ”¹ï¼Œç¼ºç‚¹å¦‚æœç”¨ä¾‹æ¯”è¾ƒå¤šï¼Œæµ‹è¯•ä»£ç ä¼šå¾ˆé•¿ã€‚

```cpp
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
        // ç¬¬äºŒä¸ª WHEN æ‰§è¡Œæ—¶ä¼šé‡æ–°ä» GIVEN è¿è¡Œï¼Œä¸å—å‰ä¸€ä¸ª WHEN å½±å“
        WHEN("Input one another char")
        {
            auto encoded = soundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

- ç¬¬äºŒç§ä¾¿æ˜¯ä½¿ç”¨ class fixture æ–¹æ³•ï¼ŒGIVEN ä¸ WHEN å­˜åœ¨é‡å¤ï¼Œè™½ç„¶æœ¬æ–‡é‡‡ç”¨çš„å•å…ƒæµ‹è¯•ç¼–å†™é£æ ¼æ˜¯ BDD-ScenarioGivenWhenThen ä½†æ˜¯å¯¹äºçŸ­å°çš„æµ‹è¯•çŸ­å¦‚æœæµ‹è¯•åç§°å¯ä»¥æè¿°æ¸…æ¥šå…¶ç›®çš„ï¼Œé‚£ä¹ˆå°±æ²¡æœ‰å¿…è¦å¤ªå•°å—¦ï¼š

```cpp
class FixtureSoundex
{
public:
    Soundex MSoundex;
};

TEST_CASE_METHOD(FixtureSoundex, "Retain sole letter of one letter world", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("A"), Equals("A000"));
}

TEST_CASE_METHOD(FixtureSoundex, "Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("I"), Equals("I000"));
}
```

Catch2 ä¼šåœ¨è¿è¡Œæ¯ä¸ªæµ‹è¯•æ—¶åˆ›å»º fixture å®ä¾‹ã€‚ç°åœ¨å°±å¯ä»¥åˆ é™¤æµ‹è¯•å†…çš„å±€éƒ¨å˜é‡ soundexã€‚ç°åœ¨ Soundex ä»£ç æœ‰äº›é•¿äº†ï¼Œæ˜¯æ—¶å€™è¦æŠŠ TODO äº‹é¡¹è§£å†³ä¸€ä¸‹ã€‚

```cpp
//Include/Soundex.h
#pragma once

#include <string>

// !TODO: æš‚æ—¶å°†å®ç°ä¹Ÿéƒ½æ”¾å…¥åŒä¸€ä¸ªæ–‡ä»¶ä¸­æ¯”è¾ƒæ–¹ä¾¿ä¿®æ”¹ï¼Œåç»­åˆé€‚çš„æ—¶æœºæŠ½å‡º
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(Word); }

private:
    /**
     * @brief å®‰è£… Soundex æ¡æ¬¾4 è¦æ±‚è¿›è¡Œè¡¥é›¶
     *
     * @param Word
     * @return std::string
     */
    std::string zeroPad(const std::string& Word) const { return Word + "000"; }
};

```

æµ‹è¯•ä»£ç ï¼š

```cpp
//test/Catch2/TestSoundex.cpp
#include "Soundex.h"
#include "catch2/catch.hpp"
#include "spdlog/spdlog.h"
using namespace Catch;

class FixtureSoundex
{
public:
    Soundex MSoundex;
};

TEST_CASE_METHOD(FixtureSoundex, "Retain sole letter of one letter world", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("A"), Equals("A000"));
}

TEST_CASE_METHOD(FixtureSoundex, "Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("I"), Equals("I000"));
}
```

## æ€ç´¢ä¸æµ‹è¯•é©±åŠ¨å¼€å‘

ç®€å•åœ°è¯´ï¼ŒTDDçš„å‘¨æœŸå°±æ˜¯å†™ä¸€ä¸ªæµ‹è¯•ï¼Œå…ˆç¡®ä¿æµ‹è¯•å¤±è´¥ï¼Œç„¶åç¼–ç è®©æµ‹è¯•é€šè¿‡ï¼Œæ¥ç€å®¡é˜…ä»£ç å’Œæ‰“ç£¨è®¾è®¡ï¼ˆåŒ…æ‹¬æµ‹è¯•çš„è®¾è®¡ï¼‰ï¼Œæœ€åç¡®ä¿æ‰€æœ‰æµ‹è¯•ä¾ç„¶é€šè¿‡ã€‚

æ¥ä¸‹æ¥å°†è¦å¤„ç†è§„åˆ™2ï¼šå³åœ¨ç¬¬ä¸€ä¸ªå­—æ¯åï¼Œç”¨æ•°å­—æ›¿æ¢è¾…éŸ³ã€‚æ›¿æ¢è§„åˆ™è¡¨ä¸­å­—æ¯ b å¯¹åº”æ•°å­— 1ï¼Œä»¥æ­¤ç¼–å†™ç”¨ä¾‹ï¼š

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Replace consonants with appropriate numbers", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("Ab"), Equals("A100"));    
}
```

ä¸å‡ºæ‰€æ–™çš„å¤±è´¥ï¼Œæ¥ä¸‹æ¥ä¾¿æ˜¯è®©æµ‹è¯•é€šè¿‡ï¼Œç„¶åé‡æ„åŠŸèƒ½ä»£ç ã€‚åœ¨å¯»æ±‚è§£å†³æ–¹æ¡ˆæ—¶ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦æ‰¾åˆ°ä¸€ä¸ªé€šç”¨çš„æ–¹æ³•ï¼Œ**ä½†æ˜¯ä¹Ÿä¸è¦ä½¿ç”¨å·²æœ‰çš„å¤„ç†é€»è¾‘**ï¼Œä¾‹å¦‚ï¼š

```cpp
std::string encode(const std::string& word) const {
    if (word == "Ab") return "A100";
    return zeroPad(word);
}
```

ç¼–å†™äº†è¿™ä¸ªç‰¹ä¾‹ï¼Œä½†æ˜¯çœ‹èµ·æ¥å®ƒå°±åƒå¯¹ Ab è¿›è¡Œç‰¹æ®Šå¤„ç†æˆ A1 åçš„è¡¥é›¶è¾“å‡ºï¼Œä½†æ˜¯æˆ‘ä»¬å·²æœ‰ zeroPad äº†ï¼Œè™½è¯´ç‰¹ä¾‹å¹¶éé”™è¯¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨å…¶ä»–çš„æµ‹è¯•ç”¨ä¾‹æ¥ä¿®æ”¹è¿™ä¸ªç‰¹ä¾‹ï¼Œè¿™é‡Œä»…ä»…æ˜¯åˆ—ä¸¾å‡ºå½“æˆ‘æƒ³è¦åŠŸèƒ½å‘å‰å¼€å‘æ—¶çš„æ ‡å‡†ï¼Œå› ä¸ºä¸€ç›´æ·»åŠ ç‰¹ä¾‹ä¹Ÿæ˜¯å¯è¡Œçš„ä¸æ˜¯ä¹ˆğŸ˜€ã€‚

```cpp
/**
 * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
 *
 * @param word
 * @return std::string
 */
std::string encode(const std::string& Word) const
{
    auto encoded = Word.substr(0, 1);

    if (Word.length() > 1) { encoded += "1"; }
    return zeroPad(encoded);
}
```

Opsï¼Œè¡¥é›¶å‡ºç°äº†é”™è¯¯ï¼š

```shell
/home/caolei/WorkSpace/TDD_Learning/test/Catch2/TestSoundex.cpp:43: FAILED:
  REQUIRE_THAT( encoded, Equals("A100") )
with expansion:
  "A1000" equals: "A100"

===============================================================================
test cases: 3 | 2 passed | 1 failed
assertions: 3 | 2 passed | 1 failed
```

ä¿®æ”¹ zeroPad æ–¹æ³•ä»¥é€šè¿‡æµ‹è¯•ï¼š

```cpp
/**
 * @brief å®‰è£… Soundex æ¡æ¬¾4 è¦æ±‚è¿›è¡Œè¡¥é›¶
 *
 * @param Word
 * @return std::string
 */
std::string zeroPad(const std::string& Word) const
{
    auto zerosNeeded = 4 - Word.length();
    return Word + std::string(zerosNeeded, '0');
}
```

ç°åœ¨çœ‹èµ·æ¥ä¸é”™ï¼Œç”¨ä¾‹ä¹Ÿå·²ç»é€šè¿‡äº†ã€‚ä½†æ˜¯å¯¹äº encode æ–¹æ³•çš„å®ç°è¿˜æ˜¯æœ‰äº›ä¸æ»¡æ„ï¼Œå…¶ä¸­å……æ–¥äº†ä¸€äº›ç¼–ç ç»†èŠ‚å’Œé­”æ•°ï¼Œå¯¹äºä¸ç†Ÿæ‚‰åŠŸèƒ½çš„å…¶ä»–äººé˜…è¯»èµ·æ¥æ˜¯ç¾éš¾çš„ï¼Œä¸å¤šåºŸè¯é‡æ„å®ƒğŸš€ï¼š

```cpp
#pragma once

#include <string>

// !TODO: æš‚æ—¶å°†å®ç°ä¹Ÿéƒ½æ”¾å…¥åŒä¸€ä¸ªæ–‡ä»¶ä¸­æ¯”è¾ƒæ–¹ä¾¿ä¿®æ”¹ï¼Œåç»­åˆé€‚çš„å®é™…æŠ½å‡º
/**
 * @brief Soundex ç®—æ³•ç±»
 *
 */
class Soundex
{
public:
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(head(Word) + encodedDigits(Word)); }

private:
    /**
     * @brief è·å–å•è¯çš„ç¬¬ä¸€ä¸ªå­—æ¯
     *
     * @param Word
     * @return std::string
     */
    std::string head(const std::string& Word) const { return Word.substr(0, 1); }

    /**
     * @brief è·å–é¦–å­—æ¯åå…¶ä»–å­—ç¬¦è½¬åŒ–çš„å¯¹åº”æ•°å­—
     *
     * @param Word
     * @return std::string
     */
    std::string encodedDigits(const std::string& Word) const
    {
        if (Word.length() > 1) return "1";
        return "";
    }
    /**
     * @brief æŒ‰ç…§ Soundex çš„è§„åˆ™è¦æ±‚è¿›è¡Œè¡¥é›¶
     *
     * @param Word
     * @return std::string
     */
    std::string zeroPad(const std::string& Word) const
    {
        auto zerosNeeded = 4 - Word.length();
        return Word + std::string(zerosNeeded, '0');
    }
};
```

ä»¥å£°æ˜æ€§çš„æ–¹å¼ç»„ç»‡ä»£ç ï¼Œä½¿å…¶éå¸¸æ˜“äºç†è§£ã€‚è®¾è®¡ä¸­éå¸¸é‡è¦çš„ä¸€æ–¹é¢æ˜¯ä»å®ç°ï¼ˆæ€ä¹ˆåšï¼‰ä¸­åˆ†ç¦»æ¥å£ï¼ˆåšä»€ä¹ˆï¼‰ï¼Œè¿™æä¾›äº†è¿ˆå‘æ›´é«˜å±‚æ¬¡è®¾è®¡æ–¹æ¡ˆçš„è·³æ¿ã€‚

>æœ‰æ—¶ä¹Ÿä¼šæ‹…å¿ƒä¸€äº›å®ç°çš„ç»†èŠ‚å¹¶ä¸æ˜¯é‚£ä¹ˆå¥½ï¼šã€‚ç¬¬ä¸€ï¼Œæ˜¯ä¸æ˜¯åº”è¯¥ç”¨ stringstreamï¼Œè€Œä¸æ˜¯ç›´æ¥å°†å­—ç¬¦ä¸²è¿æ¥èµ·æ¥ï¼Ÿç¬¬äºŒï¼Œä¸ºä»€ä¹ˆä¸å°½å¯èƒ½åœ°ç”¨å•ç‹¬çš„ charï¼Ÿä¾‹å¦‚ï¼Œä¸ºä»€ä¹ˆç”¨ return words.substr(0, 1); è€Œé return word.front();ï¼Ÿç¬¬ä¸‰ï¼Œç”¨ return std::string(); ä¸æ˜¯æ¯” return ""; æ›´å¥½å—ï¼Ÿ
>
> è¿™äº›æ›¿ä»£çš„ä»£ç æ–¹æ¡ˆå¯èƒ½æ›´å¥½ã€‚ä½†è¿™äº›éƒ½æ˜¯è¿‡æ—©ä¼˜åŒ–ï¼ˆpremature optimizationï¼‰ã€‚è¿™ä¸ªæ—¶å€™ï¼Œä¸€ä¸ªå¥½çš„è®¾è®¡ï¼ˆæ¥å£ä¸€è‡´ä¸”ä»£ç å¯è¯»æ€§é«˜ï¼‰æ›´é‡è¦ã€‚ä¸€æ—¦ä»¥ç‰¢é çš„è®¾è®¡å®ç°äº†æ­£ç¡®çš„è¡Œä¸ºåï¼Œå†è€ƒè™‘æ˜¯å¦ä¼˜åŒ–æ€§èƒ½ã€‚

å…ˆä¸è¦è€ƒè™‘å¯¹äºæ€§èƒ½è¿›è¡Œä¼˜åŒ–ï¼Œè¿˜æ˜¯è¦ä¼˜å…ˆè€ƒè™‘å¥½çš„ä»£ç è®¾è®¡ï¼Œä¾‹å¦‚æ¶ˆé™¤ä»£ç ä¸­çš„`é­”æ•°`ï¼Œå–è€Œä»£ä¹‹ä¸€ä¸ªåˆç†åå­—çš„å¸¸é‡ã€‚

```cpp
static const size_t MaxCodeLength{4};
......
/**
 * @brief å®‰è£… Soundex çš„è§„åˆ™è¦æ±‚è¿›è¡Œè¡¥é›¶
 *
 * @param Word
 * @return std::string
 */
std::string zeroPad(const std::string& Word) const
{
    auto zerosNeeded = MaxCodeLength - Word.length();
    return Word + std::string(zerosNeeded, '0');
}
```

å¯¹äº encodedDigits() ä¸­çš„ç¡¬ç¼–ç  `1`ï¼Œéœ€è¦ä»£ç å°†å­—æ¯ b æ›¿æ¢æˆ 1ï¼Œè€Œå†™åç»­è¿˜è¦æ”¯æŒå¯¹å…¶ä»–å­—ç¬¦çš„æ•°å­—è½¬æ¢ï¼Œå¯ä»¥é€šè¿‡ä¸€ä¸ªåˆç†çš„å‡½æ•°åå­—æ›¿ä»£ï¼Œæœ€ç»ˆçš„ä»£ç å¦‚ä¸‹ï¼š

```cpp
/**
 * @brief è·å–é¦–å­—æ¯åå…¶ä»–å­—ç¬¦è½¬åŒ–çš„å¯¹åº”æ•°å­—
 *
 * @param Word
 * @return std::string
 */
std::string encodedDigits(const std::string& Word) const
{
    if (Word.length() > 1) return encodedDigit();
    return "";
}

/**
 * @brief è·å–ä¸€ä¸ªå­—ç¬¦å¯¹åº”çš„æ•°å­—
 *
 * @return std::string
 */
std::string encodedDigit() const { return "1"; }
```

## æµ‹è¯•é©±åŠ¨

ç°åœ¨è¦ç»§ç»­ä½¿ç”¨ TDD æ¥ä¿ƒä½¿å¼€å‘è¿›åº¦ç»§ç»­å‘å‰ï¼Œé¦–è¦è€ƒè™‘ä¸€ç‚¹ä»¥æ­¤æ—¶é©±åŠ¨å¼€å‘æ›´å¤šçš„è¾…éŸ³å˜æ¢é€»è¾‘ï¼Œä½¿è§£å†³æ–¹æ¡ˆæ›´åŠ å…·æœ‰é€šç”¨æ€§ï¼Œæ˜¯åº”è¯¥ç»§ç»­åœ¨ `Replace consonants with appropriate numbers` å¢åŠ æ›´å¤šä¾‹å­çš„æ–­è¨€åˆ¤æ–­ï¼Œè¿˜æ˜¯æ–°å¢ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹å‘¢ï¼Ÿ

TDD çš„ç»éªŒæ³•åˆ™æ˜¯ä¸€ä¸ªæµ‹è¯•ä¸€ä¸ªæ–­è¨€ï¼ˆå‚è€ƒ7.3èŠ‚ï¼Œè·å–æ›´å¤šä¿¡æ¯ï¼‰ã€‚æˆ‘ä»¬æå€¡ä¸“æ³¨æµ‹è¯•è¡Œä¸ºï¼Œè€Œéæµ‹è¯•åŠŸèƒ½å‡½æ•°ã€‚å¤§éƒ¨åˆ†æ—¶å€™è¦éµä»è¿™ä¸€ä¸ªè§„åˆ™ã€‚

å› æ­¤å¯¹äºç¬¬äºŒä¸ªè¾…éŸ³ç¼–ç æµ‹è¯•å¹¶ä¸æ˜¯å¦ä¸€ä¸ªè¡Œä¸ºï¼Œæˆ‘ä»¬å°†å®ƒåŠ åˆ°åŒä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹é‡Œï¼ŒåŒæ—¶å¸Œæœ›å½“ä¸€ä¸ªæ–­è¨€å¤±è´¥åå…¶ä»–ç”¨ä¾‹å¯ä»¥ç»§ç»­æ‰§è¡Œï¼Œè¿™é‡Œä½¿ç”¨ CHECK æ¥è¿›è¡Œæ£€æŸ¥ï¼ŒåŒæ—¶å¯ä»¥ä½¿ç”¨ SECTION æ–¹å¼ç¼–å†™æµ‹è¯•ä»£ç ï¼š

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Replace consonants with appropriate numbers", "[SoundexEncoding]")
{
    SECTION("Test to replace the consonants in the entered words with appropriate numbers")
    {
        CHECK_THAT(MSoundex.encode("Ab"), Equals("A100"));
        CHECK_THAT(MSoundex.encode("Ac"), Equals("A200"));
    }
}
```

ä¿®æ”¹ä»£ç ä¿è¯æµ‹è¯•ç”¨ä¾‹é€šè¿‡ï¼š

```cpp
/**
 * @brief è·å–é¦–å­—æ¯åå…¶ä»–å­—ç¬¦è½¬åŒ–çš„å¯¹åº”æ•°å­—
 *
 * @param Word
 * @return std::string
 */
std::string encodedDigits(const std::string& Word) const
{
    if (Word.length() > 1) return encodedDigit(Word[1]);
    return "";
}

/**
 * @brief è·å–ä¸€ä¸ªå­—ç¬¦å¯¹åº”çš„æ•°å­—
 *
 * @param Letter
 * @return std::string
 */
std::string encodedDigit(char Letter) const
{
    if (Letter == 'c') return "2";
    return "1";
}
```

ç°åœ¨å†æ·»åŠ ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ä½“ç°æ›´å¤šçš„æ•°æ®è¾“å…¥æƒ…å†µï¼š

```cpp
...
CHECK_THAT(MSoundex.encode("Ab"), Equals("A100"));
CHECK_THAT(MSoundex.encode("Ac"), Equals("A200"));
CHECK_THAT(MSoundex.encode("Ad"), Equals("A300"));
...
```

æŒ‰ç…§ä¹‹å‰ä¸€æ ·çš„æ­¥éª¤æ·»åŠ è¿™æ¬¡çš„åŠŸèƒ½å—ï¼Ÿä¸ ğŸ’£ï¼Œè¿™æ—¶å°±ä¼šå‘ç°åŠŸèƒ½å®ç°ä»£ç å¼€å§‹æœ‰é‡å¤çš„é€»è¾‘äº§ç”Ÿï¼Œæ˜¯æ—¶å€™å°†å…¶é‡æ„ä»¥æ›´åŠ é€šç”¨çš„å®ç°ï¼Œè¿™é‡Œä½¿ç”¨ä¸€ä¸ª hash é›†åˆä»£æ›¿ç®€å•é‡å¤çš„ if åˆ†æ”¯åˆ¤æ–­ï¼š

```cpp
/**
 * @brief è·å–ä¸€ä¸ªå­—ç¬¦å¯¹åº”çš„æ•°å­—
 *
 * @param Letter
 * @return std::string
 */
std::string encodedDigit(char Letter) const
{
    const std::unordered_map<char, std::string> encodings { { 'b', "1" }, { 'c', "2" }, { 'd', "3" } };
    return encodings.find(Letter)->second;
}
```

åº”è¯¥ç»§ç»­å°†å…¶ä½™æ‰€æœ‰çš„è¾…éŸ³è½¬æ¢ï¼Œéƒ½ä»¥æµ‹è¯•é©±åŠ¨çš„æ–¹å¼å¼€å‘ä¹ˆï¼Œæ˜¯å¦åº”è¯¥è¦†ç›–æ‰€æœ‰å¯èƒ½å‡ºé—®é¢˜çš„åœ°æ–¹â“

è¯·æ³¨æ„æˆ‘ä»¬å®åœ¨è¿›è¡Œ`æµ‹è¯•é©±åŠ¨å¼€å‘`ï¼Œè€Œéæµ‹è¯•ã€‚TDD ç€åŠ›äºä»£ç è®¾è®¡ã€‚æµ‹è¯•ä¸»è¦ç”¨äºè¡¨è¿°ä½ è¦æ„å»ºçš„è¡Œä¸ºã€‚TDD è¿‡ç¨‹ä¸­ç¼–å†™çš„æµ‹è¯•å¤§éƒ½æ˜¯è¿™ä¸ªæµç¨‹çš„é™„å±äº§ç‰©ã€‚æœ‰äº†è¿™äº›æµ‹è¯•ï¼Œåœ¨æ¥ä¸‹æ¥æ”¹åŠ¨ä»£ç æ—¶ï¼Œä½ ä¼šæ›´æœ‰ä¿¡å¿ƒã€‚è€Œä¸” TDD çš„ä¸€ä¸ªé‡è¦æ–¹é¢å°±æ˜¯å¤Ÿç”¨å³å¯ï¼Œåœ¨å¼€å‘æ–°åŠŸèƒ½å³è¡Œä¸ºæ—¶ï¼Œç¼–å†™æµ‹è¯•è¦†ç›–ï¼Œè€Œé€»è¾‘ä»£ç ä¸åœ¨æ”¹å˜æ—¶ï¼Œå°±ä¸ç”¨ç¼–å†™æµ‹è¯•ä»£ç äº†ã€‚

æ—¢ç„¶å¦‚æ­¤ï¼Œé‚£ä¹ˆå…ˆå®Œæˆè½¬æ¢è¡¨ï¼š

```cpp
const std::unordered_map<char, std::string> encodings { 
    { 'b', "1" }, { 'f', "1" }, { 'p', "1" }, { 'v', "1" },
    { 'c', "2" }, { 'g', "2" }, { 'j', "2" }, { 'k', "2" }, { 'q', "2" }, 
                                { 's', "2" }, { 'x', "2" }, { 'z', "2" },
    { 'd', "3" }, { 't', "3" }, 
    { 'l', "4" }, 
    { 'm', "5" }, { 'n', "5" }, 
    { 'r', "6" } };
```

å…³äºå¯¹åº”çš„æµ‹è¯•ç¨‹åº `Replace consonants with appropriate numbers` éœ€è¦æ€è€ƒå…¶ä¸­çš„ä¸‰ä¸ªæ–­è¨€æ˜¯å¦èƒ½å¢åŠ å¯¹äºæ­¤åŠŸèƒ½çš„ç‰¹æ€§ç†è§£ï¼Œæˆ–è€…å¯¹ç‰¹æ®Šçš„è¡Œä¸ºæœ‰æè¿°ã€‚å¦‚æœæ²¡æœ‰é‚£ä¹ˆå°±å¯ä»¥ç®—ä½œé‡å¤çš„æµ‹è¯•å°†å…¶åˆ é™¤äº†ï¼Œæœ€ç»ˆä½¿ç”¨æ–­è¨€å¹¶é€‰ä¸€ä¸ªä¸åŒçš„è¾…éŸ³æ¥è¿›è¡Œæµ‹è¯•ï¼š

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Replace consonants with appropriate numbers", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("Ax"), Equals("A200"));
}
```

## å¦‚æœå‡ºç°åˆ«çš„æƒ…å†µå‘¢

ç°åœ¨å®ç°çš„ encodedDigit æ˜¯å‡å®šèƒ½å¤Ÿåœ¨ encodings æ˜ å°„ä¸­æ‰¾åˆ°ä¼ å…¥çš„å­—æ¯ï¼Œä¹‹å‰ä¸ºäº†ä»¥æœ€ä½é™åº¦é€šè¿‡æµ‹è¯•æ‰€åšçš„å‡è®¾ï¼Œç°åœ¨éœ€è¦è€ƒè™‘å…¶ä»–çš„æƒ…å†µï¼Œå³æœ‰æ²¡æœ‰å¯èƒ½ä¼ å…¥çš„å­—æ¯æ²¡æœ‰åœ¨æ˜ å°„ä¸­æ‰¾åˆ°ï¼Ÿå‘ç”Ÿæ—¶å¦‚ä½•è§£å†³ã€‚

Soundex å¦‚ä½•è§£å†³ä¸èƒ½è¯†åˆ«çš„å­—æ¯ï¼Ÿå¯ä»¥é€šè¿‡å®¢æˆ·æˆ–è€… Wiki ç™¾ç§‘äº†è§£åˆ°ï¼Œå³å¿½ç•¥ã€‚è¾“å…¥ A# å¾—åˆ° A000ã€‚ç°åœ¨ä¸ºè¿™ä¸ªè¡Œä¸ºç¼–å†™ä¸€äº›åˆ—å¤–çš„æƒ…å½¢æµ‹è¯•ã€‚

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Ignore nonrecognition characters", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("A#"), Equals("A000"));
}
```

ä¿®æ”¹ä»£ç ä»¥é€šè¿‡æµ‹è¯•ï¼š

```cpp
/**
 * @brief è·å–ä¸€ä¸ªå­—ç¬¦å¯¹åº”çš„æ•°å­—
 *
 * @param Letter
 * @return std::string
 */
std::string encodedDigit(char Letter) const
{
    // clang-format off
    const std::unordered_map<char, std::string> encodings { 
        { 'b', "1" }, { 'f', "1" }, { 'p', "1" }, { 'v', "1" },
        { 'c', "2" }, { 'g', "2" }, { 'j', "2" }, { 'k', "2" }, { 'q', "2" }, 
                                    { 's', "2" }, { 'x', "2" }, { 'z', "2" },
        { 'd', "3" }, { 't', "3" }, 
        { 'l', "4" }, 
        { 'm', "5" }, { 'n', "5" }, 
        { 'r', "6" } };
    // clang-format on

    auto it = encodings.find(Letter);
    return it == encodings.end() ? "" : it->second;
}
```

å½“é€šè¿‡ TDD å®Œæˆä¸€ä¸ªå‘¨æœŸçš„åŠŸèƒ½æ—¶ï¼Œå¾€å¾€åœ¨é‡æ„ç¯èŠ‚å°±å¯ä»¥å¼€å§‹è€ƒè™‘å®Œå–„è¿™ä¸ªåŠŸèƒ½ï¼Œå¦‚åŒæ­¤ä¾‹ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥è®¤ä¸ºé’ˆå¯¹å•ä¸€å­—ç¬¦è¾“å…¥ä¸ºå‰æå¯ä»¥æ­£ç¡®çš„è¿›è¡Œè½¬æ¢äº†ã€‚

## ä¸€æ¬¡åªåšä¸€ä»¶äº‹

å½“å®Œæˆå•ä¸€å­—ç¬¦çš„è½¬æ¢ï¼Œç°åœ¨éœ€è¦é€šè¿‡æµ‹è¯•é©±åŠ¨å¼€å‘å‡ºç”¨ä»¥è½¬æ¢ä¸€ä¸ªè¯æœ«å°¾å‰©ä¸‹çš„å­—æ¯äº†ã€‚

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Replaces multiple consonants with digits", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("Acdl"), Equals("A234"));
}
```

ç®€å•çš„åŠæ³•ä¾¿æ˜¯é™¤ç¬¬ä¸€ä¸ªå­—æ¯ï¼Œéå†å‰©ä¸‹çš„å­—æ¯å¹¶è½¬æ¢ã€‚ä½†æ˜¯å½“å‰çš„ä»£ç ç»“æ„å¹¶ä¸å®¹æ˜“æ”¯æŒï¼Œå¯ä»¥å…ˆé‡æ„ä¸‹ä»£ç ã€‚

ä½†æ˜¯è¯·æ³¨æ„ï¼Œ**ä¸€æ¬¡åªåšä¸€ä»¶äº‹ã€‚æµ‹è¯•é©±åŠ¨å¼€å‘æ—¶ï¼Œè¦ä¿æŒæ¯ä¸€æ­¥éƒ½ä¸åŒã€‚**å†å†™æµ‹è¯•æ—¶ï¼Œä¸è¦è·‘å»é‡æ„ã€‚åŒæ ·ï¼Œåœ¨å°è¯•è®©æµ‹è¯•é€šè¿‡æ—¶ä¹Ÿä¸è¦å»é‡æ„ã€‚å¹¶è¡Œæ€»æ˜¯å®¹æ˜“å‡ºé”™ï¼Œä¸æ˜¯ä¹ˆğŸ›ã€‚

ä¸ºäº†ä¾¿äºé‡æ„ï¼Œå…ˆå°†æˆ‘ä»¬åˆšæ‰çš„æµ‹è¯•æ³¨é‡Šæ‰ï¼Œ`[.]` æ ‡è¯†ä¼šä½¿ Catch2 è·³è¿‡è¿™ä¸ªæµ‹è¯•ã€‚

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Replaces multiple consonants with digits", "[.][SoundexEncoding]")
```

é‡æ„ä¸‹å½“å‰è§£å†³æ–¹æ¡ˆã€‚ä¸è¦å°†æ•´ä¸ªè¯ä¼ å…¥encodedDigits()ï¼Œè€Œæ˜¯å°†è¯å°¾ï¼ˆé™¤äº†ç¬¬ä¸€ä¸ªå­—æ¯å¤–çš„å…¶ä½™å­—æ¯ï¼‰ä¼ å…¥encodedDigits()ï¼Œè¿™æ ·éå†æ›´åŠ ç®€æ´ã€‚

```cpp
...
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(head(Word) + encodedDigits(tail(Word))); }

...
    /**
     * @brief è·å–å•è¯é™¤äº†ç¬¬ä¸€ä¸ªå­—æ¯å¤–çš„å…¶ä½™å­—æ¯
     *
     * @param Word
     * @return std::string
     */
    std::string tail(const std::string& Word) const { return Word.substr(1); }
...
    /**
     * @brief è·å–é¦–å­—æ¯åå…¶ä»–å­—ç¬¦è½¬åŒ–çš„å¯¹åº”æ•°å­—
     *
     * @param Word
     * @return std::string
     */
    std::string encodedDigits(const std::string& Word) const
    {
        if (Word.empty()) return "";
        return encodedDigit(Word.front());
    }
```

è¿è¡Œä¸‹æµ‹è¯•ç¡®ä¿æ”¹åŠ¨ä¸ä¼šç ´è¯å…¶ä»–åŠŸèƒ½ã€‚å›åˆ° TDD å‘¨æœŸå¼€å§‹ï¼Œå¯ç”¨è¢«æš‚æ—¶ç¦æ‰çš„æµ‹è¯• `"Replaces multiple consonants with digits"` ï¼Œä½¿å…¶å¤±è´¥ã€‚

```cpp
    /**
     * @brief è·å–é¦–å­—æ¯åå…¶ä»–å­—ç¬¦è½¬åŒ–çš„å¯¹åº”æ•°å­—
     *
     * @param Word
     * @return std::string
     */
    std::string encodedDigits(const std::string& Word) const
    {
        std::string encoding;
        for (auto letter : Word)
            encoding += encodedDigit(letter);
        return encoding;
    }
```

é€šè¿‡ for å¾ªç¯éå†æ¯ä¸ªå­—æ¯ï¼Œè¿™æ ·ä¸åœ¨éœ€è¦å¯¹ Word è¿›è¡Œåˆ¤ç©ºäº†ï¼Œåˆ é™¤ä¹‹ã€‚

## é™åˆ¶é•¿åº¦

è§„åˆ™ 4 å£°æ˜ Soundex ç¼–ç ç»“æœå¿…é¡»æ˜¯ 4 ä¸ªå­—ç¬¦ï¼Œä¸ºæ­¤è¡Œä¸ºå¢åŠ æ–°çš„æµ‹è¯•ã€‚

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Limits length to four characters", "[SoundexEncoding]")
{
    REQUIRE(MSoundex.encode("Dcdlb").length() == 4);
}
```

å®šä½é—®é¢˜é•¿å¤„è¶…å‡ºï¼Œä¿®å¤é—®é¢˜ï¼š

```cpp
    /**
     * @brief è·å–é¦–å­—æ¯åå…¶ä»–å­—ç¬¦è½¬åŒ–çš„å¯¹åº”æ•°å­—
     *
     * @param Word
     * @return std::string
     */
    std::string encodedDigits(const std::string& Word) const
    {
        std::string encoding;
        for (auto letter : Word)
        {
            if (encoding.length() == MaxCodeLength - 1) break;
            encoding += encodedDigit(letter);
        }
        return encoding;
    }
```

é‡æ„ä¸‹ä»£ç ï¼Œæ›´å¥½çš„è¡¨è¾¾å«ä¹‰ï¼š

```cpp
    /**
     * @brief è·å–é¦–å­—æ¯åå…¶ä»–å­—ç¬¦è½¬åŒ–çš„å¯¹åº”æ•°å­—
     *
     * @param Word
     * @return std::string
     */
    std::string encodedDigits(const std::string& Word) const
    {
        std::string encoding;
        for (auto letter : Word)
        {
            if (isComplete(encoding)) break;
            encoding += encodedDigit(letter);
        }
        return encoding;
    }

    /**
     * @brief å®Œæˆå­—ç¬¦ä¸²çš„ Soundex è§„åˆ™ç¼–ç 
     *
     * @param Encoding
     * @return true
     * @return false
     */
    bool isComplete(const std::string& Encoding) const { return Encoding.length() == MaxCodeLength - 1; }
```

## ä¸¢æ‰å…ƒéŸ³

è§„åˆ™ 1 è¯´è¦ä¸¢æ‰æ‰€æœ‰çš„å…ƒéŸ³ä»¥åŠ wã€h å’Œ yã€‚ç°åœ¨ä¸ºæ­¤åŠŸèƒ½æ·»åŠ æµ‹è¯•ç”¨ä¾‹ã€‚

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Ignores Vowel like letters", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("Baeiouhycdl"), Equals("B234"));
}
```

è¿è¡Œä¸‹æµ‹è¯•å‘ç°æ˜¯é€šè¿‡çš„ï¼Œä¸»è¦æ˜¯ç”±äº encodedDigit() å¯¹äºè½¬æ¢è¡¨ä¸­æ‰¾ä¸åˆ°çš„å­—æ¯ä¼šè¿”å›ç©ºå­—ç¬¦ä¸²ã€‚

è¿™é‡Œéœ€è¦æ³¨æ„ä¸‹ï¼šå¦‚æœæ²¡æœ‰æ”¹åŠ¨ç±»å®šä¹‰ï¼Œæµ‹è¯•å°±é€šè¿‡äº†ï¼Œé‚£èƒŒåè‚¯å®šå¦æœ‰æ•…äº‹ï¼ˆå‚è§ 3.5ï¼‰ï¼Œå¦‚æœæ¥ä¸‹æ¥çš„æµ‹è¯•ä¹Ÿéƒ½ç»§ç»­é€šè¿‡ï¼Œé‚£ä¹ˆåº”è¯¥è€ƒè™‘å›æ»šæ‰ä»£ç æ”¹åŠ¨ã€‚æµ‹è¯•æå‰é€šè¿‡çš„åŸå› ï¼Œå¯èƒ½æ˜¯ä½ çš„æ­¥ä¼æœ‰ç‚¹å¤§ï¼Œä½†è¿™æ ·ä½ å¯èƒ½ä¸ä¼šæ„Ÿå—åˆ°TDDå¸¦æ¥çš„å¥½å¤„ã€‚

## è®©æµ‹è¯•è‡ªæˆ‘æ¾„æ¸…

æ¥ä¸‹æ¥å¤„ç†ä¸¤ä¸ªç›¸é‚»å­—æ¯æœ‰ç›¸åŒæ•°å­—ç¼–ç çš„æƒ…å†µã€‚å®‰è£…è§„åˆ™ 3ï¼Œå°†ç”¨ä¸€ä¸ªæ•°å­—æ ‡è¯†è¿™äº›å­—æ¯ï¼Œè¿™æ¡è§„åˆ™ä¹Ÿé€‚ç”¨äºç¬¬ä¸€ä¸ªå­—æ¯ã€‚å…ˆç”¨æµ‹è¯•æè¿°ç¬¬ä¸€ä¸ªæƒ…å†µï¼š

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Combines duplicate encodings", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("Abfcgdt"), Equals("A123"));
}
```

é“ b å’Œ f éƒ½ç¼–ç ä¸º 1ï¼Œc å’Œ g ç¼–ç ä¸º 2ï¼Œd å’Œ t ç¼–ç ä¸º 3ã€‚æœ€ç»ˆ Abfcgdt --> A123ã€‚å¯ä»¥æ·»åŠ ä¸€äº›å‰ç½®æ¡ä»¶ï¼ˆpreconditionï¼‰æ–­è¨€ï¼Œä»¥å¸®åŠ©é˜…è¯»ä»£ç çš„äººå»ºç«‹è¿™ç§å…³è”ã€‚

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Combines duplicate encodings", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encodedDigit("b"), Equals(MSoundex.encodedDigit("f")));
    REQUIRE_THAT(MSoundex.encodedDigit("c"), Equals(MSoundex.encodedDigit("g")));
    REQUIRE_THAT(MSoundex.encodedDigit("d"), Equals(MSoundex.encodedDigit("t")));

    REQUIRE_THAT(MSoundex.encode("Abfcgdt"), Equals("A123"));
}
```

è¿™é‡Œå°±éœ€è¦å°† encodedDigit è½¬åŒ–æˆ public æ¥å£ï¼Œä»è€…è§ä»ã€æ™ºè€…è§æ™ºå§ï¼Œä¸ªäººè¿˜æ˜¯è®¤ä¸ºè™½ç„¶è¿™æ ·æ›´åŠ æ–¹ä¾¿äº†åç»­è¯»å–ï¼Œä½†æ˜¯ä»£ç çš„å°è£…æ€§åŒæ ·é‡è¦ï¼Œå®¢æˆ·ä¸éœ€è¦çš„æ¥å£å®Œå…¨æ²¡æœ‰å¿…è¦æš´éœ²å‡ºæ¥ï¼Œå†™ä¸ªæ³¨é‡Šä¿¡æ¯ä¸ä¹Ÿå¾ˆå¥½ä¹ˆã€‚

```cpp
    /**
     * @brief è·å– Encoding æœ€åä¸€ä¸ªå­—ç¬¦
     *
     * @param Encoding
     * @return std::string
     */
    std::string lastDigit(const std::string& Encoding) const
    {
        if (Encoding.empty()) return "";
        return std::string(1, Encoding.back());   // string åˆå§‹åŒ–ä¸€ä¸ªå­—ç¬¦çš„æ–¹æ³•
    }
```

## è·³å‡ºè·³è·³æ¡†æ¡†æ¥æµ‹è¯•

è€ƒè™‘é‡å¤çš„ç¬¬äºŒç§æƒ…å†µï¼Œç¬¬äºŒä¸ªå­—æ¯ä¸ç¬¬ä¸€ä¸ªå­—æ¯é‡å¤ã€‚å¯ä»¥å‘ç°ç›®å‰æ‰€æœ‰çš„æµ‹è¯•éƒ½æ˜¯ä»¥ä¸€ä¸ªå¤§å†™å­—æ¯å¼€å§‹ï¼Œå…¶ä½™éƒ½æ˜¯å°å†™ï¼Œä½†è¿™ä¸ªç®—æ³•åº”è¯¥æ˜¯å¤§å°å†™æ— å…³çš„ï¼Œè¿™é‡Œå¯ä»¥å…ˆæŠŠé‡å¤çš„æµ‹è¯•æš‚åœï¼Œå…ˆå¤„ç†ä¸‹å¤§å°å†™çš„æµ‹è¯•ã€‚

ä¸ºäº†èƒ½å¤Ÿå¿«é€Ÿã€ç®€å•åœ°æ¯”è¾ƒï¼ŒSoundexç®—æ³•å°†ç±»ä¼¼çš„è¯ç¼–ç è‡³ç›¸åŒçš„ä»£ç ã€‚å­—æ¯çš„å¤§å°å†™å¹¶ä¸å½±å“å‘éŸ³ã€‚ä½†ä¸ºäº†ç®€åŒ–æ¯”è¾ƒSoundexç¼–ç ï¼Œæˆ‘ä»¬å°†è‡ªå§‹è‡³ç»ˆä½¿ç”¨ä¸€æ ·çš„å†™æ³•ã€‚

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Upper cases first letter", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("abcd"), StartsWith("A"));
}
```

ä¿®æ”¹ encode å°†é¦–å­—æ¯å¤§å†™ï¼š

```cpp
    /**
     * @brief æŒ‰ç…§ Soundex ç®—æ³•è½¬æ¢è¾“å…¥çš„å­—ç¬¦ä¸²å†…å®¹
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(upperFront(head(Word)) + encodedDigits(tail(Word))); }
.....

    /**
     * @brief è¿”å›ä¼ å…¥çš„å­—ç¬¦ä¸²é¦–å­—æ¯å¤§å†™
     *
     * @param String
     * @return std::string
     */
    std::string upperFront(const std::string& String) const
    {
        return std::string(1, std::toupper(static_cast<unsigned char>(String.front())));
    }
```

è¿˜å¯ä»¥ä¿®æ”¹ "Ignores Vowel like letters" ç”¨ä¾‹æ¥ç¡®è®¤åŠŸèƒ½ï¼š

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Ignores Vowel like letters", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("BaAeEiIoOuUhHyYcdl"), Equals("B234"));
}
```

- encodedDigits() ä¸­çš„ä»£ç æœ‰ç‚¹éšæ™¦å’Œéš¾ä»¥ç†è§£ã€‚æˆ‘ä»¬å¿…é¡»æ·±å…¥è€ƒè™‘æ¥å‘ç°ä»¥ä¸‹å‡ ç‚¹ï¼š
  1. è®¸å¤šå­—æ¯æ²¡æœ‰å¯¹åº”çš„ç¼–ç ï¼›
  2. encodedDigit() å¯¹äºä¸Šè¿°å­—æ¯ä¼šè¿”å›ç©ºå­—ç¬¦ä¸²ï¼›
  3. å°†ä¸€ä¸ªç©ºå­—ç¬¦ä¸²å’Œ encodedDigits() ä¸­çš„å˜é‡ encodings è¿æ¥èµ·æ¥æ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚

é‡æ„ä¸€ä¸‹ï¼Œä»¥ä¾¿ä»£ç æ›´åŠ æ˜äº†ã€‚å°†åˆ é™¤ç©ºå­—ç¬¦ä¸²ä½¿ç”¨ä¸€ä¸ªç‰¹æ®Šçš„å­—ç¬¦ä¼ æ›¿ä»£ï¼Œæ˜¾å¼åˆ¤æ–­æ— ç”¨çš„å­—ç¬¦ä¸åœ¨è¿›è¡Œç©ºå­—ç¬¦ä¸²æ‹¼æ¥ã€‚

```cpp
const std::string NotADigit("*");
.....
std::string encodedDigit(char Letter) const
{
.....

    auto it = encodings.find(Letter);
    return it == encodings.end() ? NotADigit : it->second;
}
.....
std::string encodedDigits(const std::string& Word) const
{
    std::string encoding;
    for (auto letter : Word)
    {
        if (isComplete(encoding)) break;

        auto digit = encodedDigit(letter);
        if (digit != NotADigit && digit != lastDigit(encoding)) { encoding += digit; }
    }
    return encoding;
}
.....
std::string lastDigit(const std::string& Encoding) const
{
    if (Encoding.empty()) return NotADigit;
    return std::string(1, Encoding.back());   // string åˆå§‹åŒ–ä¸€ä¸ªå­—ç¬¦çš„æ–¹æ³•
}
```

æ¥ä¸‹æ¥å¤„ç†ä¸€ä¸ªè¾…éŸ³å¤§å°å†™çš„æµ‹è¯•ï¼š

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Ignores case when encoding consonants", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("BCDL"), Equals(MSoundex.encode("Bcdl")));
}
```

å®ƒå£°æ˜äº†å¯¹"BCDL"å’Œ"Bcdl"çš„ç¼–ç ç»“æœæ˜¯ä¸€æ ·çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¹¶ä¸å…³å¿ƒå®é™…çš„ç¼–ç æ˜¯ä»€ä¹ˆï¼Œåªè¦å¤§å†™çš„è¾“å…¥å’Œå°å†™çš„è¾“å…¥å¾—åˆ°çš„ç»“æœä¸€æ ·å°±è¡Œã€‚

```cpp
    /**
     * @brief è·å–ä¸€ä¸ªå­—ç¬¦å¯¹åº”çš„æ•°å­—
     *
     * @param Letter
     * @return std::string
     */
    std::string encodedDigit(char Letter) const
    {
......
        auto it = encodings.find(lower(Letter));
        return it == encodings.end() ? NotADigit : it->second;
    }

private:
.......
    /**
     * @brief å°†è¾“å…¥çš„ char å­—ç¬¦è½¬æ¢ä¸ºå°å†™
     *
     * @param C
     * @return char
     */
    char lower(char C) const { return std::tolower(static_cast<unsigned char>(C)); }
```

## è¨€å½’æ­£ä¼ 

ç°åœ¨å¼€å§‹å¤„ç†ç¬¬äºŒä¸ªå­—ç¬¦ä¸ç¬¬ä¸€ä¸ªå­—ç¬¦ç›¸åŒçš„æƒ…å†µã€‚è¿™ä¸ªå°±æ˜¯ä¿ƒä½¿æˆ‘ä»¬å…ˆå°†ç®—æ³•æ”¹å†™ä¸ºå¤§å°å†™æ— å…³çš„ï¼Œç°åœ¨ç¼–å†™è¿™ä¸ªè¡Œä¸ºæµ‹è¯•ã€‚

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Combines duplicate codes when 2nd letter duplicates 1st", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("Bbcd"), Equals("B230"));
}
```

å®ç°æ–¹æ³•ä¹Ÿå¾ˆç®€å•ï¼Œå°±æ˜¯å°†éœ€è¦ç¼–ç çš„è¯ä»ä¹‹å‰çš„ä¹‹å°†è¯å°¾ä¼ å…¥ encodedDigits() æ”¹ä¸ºå°†æ•´ä¸ªè¯éƒ½ä¼ å…¥å…¶ä¸­ï¼Œä½¿å…¶å¯ä»¥å…ˆåˆ†æé¦–å­—æ¯è½¬æ¢å®Œæˆåçš„æ•°å­—ï¼Œç„¶åæ¯”å¯¹ç¬¬äºŒä¸ªå­—æ¯æ˜¯å¦éœ€è¦ä¸¢å¼ƒï¼š

```cpp
......
    std::string encode(const std::string& Word) const { return zeroPad(upperFront(head(Word)) + tail(encodedDigits(Word))); }
.....
    std::string encodedDigits(const std::string& Word) const
    {
        std::string encoding;
        encoding += encodedDigit(Word.front());

        for (auto letter : Word)
        {
            if (isComplete(encoding)) break;

            auto digit = encodedDigit(letter);
            if (digit != NotADigit && digit != lastDigit(encoding)) { encoding += digit; }
        }
        return encoding;
    }
.....
```

## é‡æ„è‡³å•ä¸€è´£ä»»çš„å‡½æ•°

æ˜¯æ—¶å€™è€ƒè™‘é‡æ„äº†ï¼Œè€ƒè™‘å•ä¸€è´£ä»»åŸåˆ™ï¼Œå‡½æ•° encodedDigits() å˜å¾—å¾ˆå¤æ‚ï¼Œå®ƒé€šè¿‡ä¸¤ä¸ªæ­¥éª¤å®Œæˆç®—æ³•ï¼š

1. å®ƒé¦–å…ˆå°†é¦–å­—æ¯çš„ç¼–ç è¿½åŠ è‡³å˜é‡encodingä¸­ï¼›
2. ç„¶åéå†å‰©ä¸‹çš„å­—æ¯ï¼Œè¿½åŠ ç»“æœè‡³encodingã€‚

å¯ä»¥å°† encodedDigits() ä¸­çš„ä¸¤ä¸ªæ­¥éª¤æå–æˆä¸¤ä¸ªå•ç‹¬çš„å‡½æ•°ï¼Œæ¯ä¸ªå‡½æ•°å„è‡ªåŒ…å«ä¸€ä¸ªæŠ½è±¡æ¦‚å¿µçš„å®ç°ç»†èŠ‚ã€‚å¦‚æ­¤ï¼ŒencodedDigits() ä¸­çš„ä»£ç åªæ˜¯å£°æ˜äº†è§£å†³æ–¹æ¡ˆçš„ç­–ç•¥ã€‚

```cpp
    /**
     * @brief è·å–é¦–å­—æ¯åå…¶ä»–å­—ç¬¦è½¬åŒ–çš„å¯¹åº”æ•°å­—
     *
     * @param Word
     * @return std::string
     */
    std::string encodedDigits(const std::string& Word) const
    {
        std::string encoding;
        encodeHead(encoding, Word);
        encodeTail(encoding, Word);
        return encoding;
    }

    /**
     * @brief å¯¹è¯é¦–å­—æ¯è¿›è¡Œç¼–ç ç¿»è¯‘
     *
     * @param Encoding
     * @param Word
     */
    void encodeHead(std::string& Encoding, const std::string& Word) const { Encoding += encodedDigit(Word.front()); }

    /**
     * @brief å¯¹è¯å°¾å­—ç¬¦è¿›è¡Œç¼–ç ç¿»è¯‘
     *
     * @param Encoding
     * @param Word
     */
    void encodeTail(std::string& Encoding, const std::string& Word) const
    {
        for (auto letter : tail(Word))
        {
            if (isComplete(Encoding)) break;

            auto digit = encodedDigit(letter);
            if (digit != NotADigit && digit != lastDigit(Encoding)) Encoding += digit;
        }
    }
```

å°† encodeTail() ä¸­çš„ for å¾ªç¯ä½“æå–å‡ºæ¥ã€‚

```cpp
    /**
     * @brief å¯¹è¯å°¾å­—ç¬¦è¿›è¡Œç¼–ç ç¿»è¯‘
     *
     * @param Encoding
     * @param Word
     */
    void encodeTail(std::string& Encoding, const std::string& Word) const
    {
        for (auto letter : tail(Word))
        {
            if (!isComplete(Encoding)) { encodeLetter(Encoding, letter); }
        }
    }

    /**
     * @brief ç¿»è¯‘å•ä¸€å­—ç¬¦ letter å¹¶æ‹¼æ¥åˆ° Encoding
     *
     * @param Encoding
     * @param Letter
     */
    void encodeLetter(std::string& Encoding, char Letter) const
    {
        auto digit = encodedDigit(Letter);
        if (digit != NotADigit && digit != lastDigit(Encoding)) { Encoding += digit; }
    }
```

è¿˜æœ‰è®¸å¤šä¼˜åŒ–ï¼Œè¯¦æƒ…å¯ä»¥çœ‹çœ‹ç¬”è®°é…å¥—çš„ç¨‹åºä»£ç ã€‚

## æ”¶å°¾å·¥ä½œ

é‚£å…ƒéŸ³æ€ä¹ˆåŠå‘¢ï¼Ÿè§„åˆ™ 3 è¯´è¢«ä¸€ä¸ªå…ƒéŸ³ï¼ˆä¸æ˜¯ h æˆ– w ï¼‰åˆ†å¼€çš„ç›¸åŒç¼–ç ï¼Œåº”è¯¥ç¼–ç ä¸¤æ¬¡ã€‚

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Does not combine duplicate encodings separate by vowels")
{
    REQUIRE_THAT(MSoundex.encode("Jbob"), Equals("J110"));
}
```

ä¿®æ”¹äº† encodeLetter() ä¸­çš„æ¡ä»¶è¡¨è¾¾å¼ï¼Œåœ¨ä¸æ˜¯é‡å¤ç¼–ç æˆ–æœ€åä¸€ä¸ªå­—æ¯æ˜¯å…ƒéŸ³çš„æƒ…å†µä¸‹ï¼Œè¿½åŠ ä¸€ä¸ªæ•°å­—ã€‚è¿™ä¸ªå£°æ˜ä¹Ÿæ•¦ä¿ƒäº†ä¸€äº›å…¶ä»–çš„ç›¸åº”æ”¹åŠ¨ã€‚

```cpp
    /**
     * @brief å¯¹è¯å°¾å­—ç¬¦è¿›è¡Œç¼–ç ç¿»è¯‘
     *
     * @param Encoding
     * @param Word
     */
    void encodeTail(std::string& Encoding, const std::string& Word) const
    {

        for (auto i = 1u; i < Word.length(); i++)
        {
            if (!isComplete(Encoding)) { encodeLetter(Encoding, Word[i], Word[i - 1]); }
        }
    }

    /**
     * @brief ç¿»è¯‘å•ä¸€å­—ç¬¦ letter å¹¶æ‹¼æ¥åˆ° Encoding
     *
     * @param Encoding
     * @param Letter
     */
    void encodeLetter(std::string& Encoding, char Letter, char LastLetter) const
    {
        auto digit = encodedDigit(Letter);
        if (digit != NotADigit && (isDuplicateLetter(Encoding, digit) || isVowel(LastLetter))) { Encoding += digit; }
    }

    /**
     * @brief åˆ¤æ–­æ˜¯å¦æ˜¯å…ƒéŸ³å­—ç¬¦
     *
     * @param Letter
     * @return true
     * @return false
     */
    bool isVowel(char Letter) const { return std::string("aeiouy").find(lower(Letter)) != std::string::npos; }

```

## æ¼äº†ä»€ä¹ˆæµ‹è¯•ç 

æˆ‘ä»¬å¾ˆå°‘æ‹¥æœ‰æ‰€æœ‰çš„è§„èŒƒã€‚å¾ˆå°‘æœ‰äººä¼šå¦‚æ­¤å¹¸è¿ã€‚å³ä¾¿æ˜¯Soundexçš„è§„åˆ™ï¼Œçœ‹ä¼¼å®Œæ•´ï¼Œå®é™…å´ä¸èƒ½è•´å«æ‰€æœ‰æƒ…å½¢ã€‚åœ¨ç¼–ç¨‹è¿‡ç¨‹ä¸­ï¼Œä¸€äº›æµ‹è¯•æˆ–ä»£ç å®ç°ç»å¸¸ä¼šæ¿€å‘æˆ‘ä»¬è¿›è¡Œå…¶ä»–æ–¹é¢çš„æ€è€ƒã€‚ä¸€èˆ¬è€Œè¨€ï¼Œè¦ä¹ˆæŠŠè¿™äº›æ€è€ƒç»“æœè®°åœ¨è„‘å­é‡Œï¼Œè¦ä¹ˆå†™åˆ°ä¸€ä¸ªåˆ—è¡¨æˆ–è®°äº‹æœ¬ä¸­ã€‚ä¸‹é¢å°±æ˜¯å¯¹Soundexè¿›è¡Œæ€è€ƒè€Œå¾—åˆ°çš„åˆ—è¡¨ã€‚

- è‹¥ç»™å®šçš„è¯ä¸­å«æœ‰åˆ†éš”ç¬¦ï¼Œå¦‚å¥ç‚¹ï¼ˆä¾‹å¦‚ï¼ŒMr.Smithï¼‰ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿåº”è¯¥å¿½ç•¥å®ƒä»¬ï¼ˆå°±åƒç°åœ¨åšçš„è¿™æ ·ï¼‰ï¼ŒæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ï¼ˆå‡å®šå®¢æˆ·åº”è¯¥æŠŠè¯åˆç†åœ°åˆ†å¥½ï¼‰ï¼Œè¿˜æ˜¯åšäº›å…¶ä»–æ“ä½œï¼Ÿè¯´åˆ°å¼‚å¸¸ï¼Œæ€æ ·ä»¥æµ‹è¯•é©±åŠ¨çš„æ–¹æ³•åœ¨ä»£ç ä¸­åŠ å…¥å¼‚å¸¸å¤„ç†ï¼Ÿåœ¨4.4.5èŠ‚ä¸­ï¼Œä½ å°†å­¦åˆ°æ€æ ·è®¾è®¡æœŸæœ›æŠ›å‡ºå¼‚å¸¸çš„æµ‹è¯•ã€‚
- ç©ºå­—ç¬¦ä¸²è¯¥æ€æ ·ç¼–ç ?ï¼ˆæˆ–è€…è¯´ï¼Œå¯ä»¥å‡å®šä¸ä¼šæ¥æ”¶åˆ°ä¸€ä¸ªç©ºå­—ç¬¦ä¸²è¾“å…¥å—ï¼Ÿï¼‰
- è¯¥æ€æ ·å¤„ç†éè‹±è¯­å­—æ¯ä¸­çš„è¾…éŸ³ï¼ˆå¦‚Ã±ï¼‰ï¼ŸSoundexç®—æ³•ä¾ç„¶é€‚ç”¨å—ï¼ŸisVowel()å‡½æ•°éœ€è¦æ”¯æŒå¸¦å˜éŸ³ç¬¦çš„å…ƒéŸ³å—ï¼Ÿ

å¦‚ä½•è§£å†³è¿™äº›é—®é¢˜åº”å¸¦é€‚æ—¶çš„åšå‡ºè‡ªå·±çš„å†³å®šï¼Œæœ€å¥½çš„æ–¹æ³•å¾€å¾€æ—¶é—®é—®å®¢æˆ·ã€‚

## è§£å†³æ–¹æ¡ˆ

ä¸€ä¸ªè§£å†³æ–¹æ¡ˆåº”å…·å¤‡çš„ä¸€äº›é‡è¦ç‰¹å¾ã€‚

- å®ƒå®ç°äº†å®¢æˆ·çš„éœ€æ±‚ã€‚å¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆä¸ç®¡æ€æ ·ï¼Œå®ƒéƒ½ä¸æ˜¯å¥½çš„è§£å†³æ–¹æ¡ˆã€‚åœ¨TDDä¸­ï¼Œä½ ç¼–å†™çš„æµ‹è¯•èƒ½å¤Ÿå¸®åŠ©ä½ äº†è§£ä½ çš„è§£å†³æ–¹æ¡ˆæ˜¯ä¸æ˜¯å®¢æˆ·è¦çš„ã€‚æ€§èƒ½å¯èƒ½æ˜¯ä¼—å¤šå®¢æˆ·éœ€æ±‚ä¸­çš„ä¸€é¡¹ã€‚ä½ çš„ä¸€éƒ¨åˆ†èŒè´£å°±æ˜¯ç†è§£ä»–ä»¬çš„æ€§èƒ½éœ€æ±‚ï¼Œå¦‚æœæ²¡å¿…è¦çš„è¯ï¼Œå°±ä¸è¦èŠ±è´¹æ—¶é—´å»åšæ€§èƒ½ä¼˜åŒ–ã€‚
- å®ƒå¯ä»¥å·¥ä½œã€‚å¦‚æœä¸€ä¸ªè§£å†³æ–¹æ¡ˆæœ‰å¤§é‡çš„ç¼ºé™·ï¼Œé‚£ä¹ˆæ„å»ºå¾—å†ä¼˜é›…ï¼Œä¹Ÿä¸æ˜¯å¥½çš„è§£å†³æ–¹æ¡ˆã€‚TDDå¯ä»¥å¸®åŠ©ç¡®å®šæˆ‘ä»¬äº¤ä»˜çš„è½¯ä»¶èƒ½ä»¥æœŸæœ›çš„æ–¹å¼å·¥ä½œã€‚TDDä¸æ˜¯é“¶å¼¹ã€‚ä½ äº¤ä»˜çš„è½¯ä»¶ä¾ç„¶ä¼šæœ‰ç¼ºé™·ï¼Œæ‰€ä»¥ç…§æ ·éœ€è¦è®¸å¤šå…¶ä»–æ–¹å¼çš„æµ‹è¯•ã€‚ä½†æ˜¯ï¼ŒTDDä¼šè®©ä½ å‘å¸ƒçš„ä»£ç åŒ…å«éå¸¸å°‘çš„ç¼ºé™·ã€‚
- å®ƒæ˜“äºç†è§£ã€‚å¯¹äºç¼–å†™å¾—ä¸å¥½çš„ä»£ç ï¼Œæ¯ä¸ªäººéƒ½éœ€è¦èŠ±è´¹å¤§é‡çš„æ—¶é—´å»ç†è§£ã€‚TDDè®©ä½ å¯ä»¥å®‰å…¨åœ°é‡æ–°ç»„ç»‡ä»£ç ä»¥æé«˜å¯è¯»æ€§ã€‚
- å®ƒæ˜“äºä¿®æ”¹ã€‚é€šå¸¸ï¼Œå®¹æ˜“ä¿®æ”¹çš„ä»£ç æ„å‘³ç€é«˜è´¨é‡çš„è®¾è®¡ã€‚TDDä½¿ä½ å¯ä»¥æŒç»­åœ°ä¿®æ”¹ï¼Œä»¥ä¿æŒè®¾è®¡çš„é«˜è´¨é‡ã€‚

## END

è‡³æ­¤ï¼Œä¾¿å®Œæˆäº†ä¸€ä¸ªå®é™…çš„ TDD è¿‡ç¨‹ã€‚
